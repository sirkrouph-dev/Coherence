[
  {
    "area": "plasticity",
    "text": "A comprehensive neuromorphic computing framework that bridges biological neuroscience and edge computing, featuring brain-inspired neural networks with realistic dynamics, plasticity, and neuromodulation.",
    "file": "README.md",
    "line": 3
  },
  {
    "area": "neuron_models",
    "text": "network.add_neuron_group(\"input\", size=100, model=\"lif\")",
    "file": "README.md",
    "line": 12
  },
  {
    "area": "neuron_models",
    "text": "network.add_neuron_group(\"output\", size=10, model=\"izhikevich\")",
    "file": "README.md",
    "line": 13
  },
  {
    "area": "plasticity",
    "text": "network.connect(\"input\", \"output\", model=\"stdp\", connectivity=0.1)",
    "file": "README.md",
    "line": 14
  },
  {
    "area": "simulation_modes",
    "text": "# Run simulation",
    "file": "README.md",
    "line": 16
  },
  {
    "area": "api_docs",
    "text": "[Full Getting Started Guide \u2192](docs/tutorials/01_getting_started.md)",
    "file": "README.md",
    "line": 22
  },
  {
    "area": "neuron_models",
    "text": "- **Biological Neuron Models**: AdEx, Hodgkin-Huxley, Izhikevich, Leaky Integrate-and-Fire",
    "file": "README.md",
    "line": 28
  },
  {
    "area": "plasticity",
    "text": "- **Synaptic Plasticity**: STDP, Short-term plasticity, Reward-modulated learning, Structural plasticity",
    "file": "README.md",
    "line": 29
  },
  {
    "area": "neuromodulation",
    "text": "- **Neuromodulatory Systems**: Dopamine, Serotonin, Acetylcholine, Norepinephrine",
    "file": "README.md",
    "line": 30
  },
  {
    "area": "sensory_encoding",
    "text": "- **Sensory Encoding**: Visual (retinal, DVS), Auditory (cochlear), Tactile (mechanoreceptor) processing",
    "file": "README.md",
    "line": 31
  },
  {
    "area": "simulation_modes",
    "text": "- **Simulation Modes**: Time-step and event-driven simulation with GPU acceleration",
    "file": "README.md",
    "line": 32
  },
  {
    "area": "edge_features",
    "text": "- **Edge Deployment**: Optimized for NVIDIA Jetson Nano and embedded systems",
    "file": "README.md",
    "line": 33
  },
  {
    "area": "simulation_modes",
    "text": "\u251c\u2500\u2500 engine/                  # Neural simulation engine",
    "file": "README.md",
    "line": 39
  },
  {
    "area": "neuron_models",
    "text": "\u2502   \u251c\u2500\u2500 neuron_models.py    # LIF, Izhikevich, AdEx, HH models",
    "file": "README.md",
    "line": 43
  },
  {
    "area": "plasticity",
    "text": "\u2502   \u251c\u2500\u2500 synapse_models.py   # Static, STDP, STP, neuromodulatory",
    "file": "README.md",
    "line": 44
  },
  {
    "area": "simulation_modes",
    "text": "\u2502   \u2514\u2500\u2500 simulator.py        # Time-step and event-driven simulation",
    "file": "README.md",
    "line": 45
  },
  {
    "area": "neuron_models",
    "text": "\u2502   \u251c\u2500\u2500 neurons.py          # Legacy neuron models",
    "file": "README.md",
    "line": 47
  },
  {
    "area": "sensory_encoding",
    "text": "\u2502   \u251c\u2500\u2500 enhanced_encoding.py # Advanced encoding (DVS, cochlear)",
    "file": "README.md",
    "line": 51
  },
  {
    "area": "neuromodulation",
    "text": "\u2502   \u251c\u2500\u2500 neuromodulation.py  # Neuromodulatory systems",
    "file": "README.md",
    "line": 52
  },
  {
    "area": "plasticity",
    "text": "\u2502   \u251c\u2500\u2500 learning.py         # Plasticity mechanisms",
    "file": "README.md",
    "line": 53
  },
  {
    "area": "performance",
    "text": "\u2502   \u251c\u2500\u2500 memory.py           # Memory subsystems",
    "file": "README.md",
    "line": 54
  },
  {
    "area": "api_docs",
    "text": "\u251c\u2500\u2500 api/                    # High-level programming interface",
    "file": "README.md",
    "line": 56
  },
  {
    "area": "api_docs",
    "text": "\u2502   \u251c\u2500\u2500 neuromorphic_api.py # Main API for system interaction",
    "file": "README.md",
    "line": 57
  },
  {
    "area": "edge_features",
    "text": "\u2502   \u251c\u2500\u2500 jetson_demo.py      # Jetson Nano deployment",
    "file": "README.md",
    "line": 62
  },
  {
    "area": "visualization_monitoring",
    "text": "\u2502   \u2514\u2500\u2500 visualize_benchmarks.py # Benchmark visualization",
    "file": "README.md",
    "line": 72
  },
  {
    "area": "neuron_models",
    "text": "\u2502   \u251c\u2500\u2500 test_neurons.py     # Neuron model tests",
    "file": "README.md",
    "line": 74
  },
  {
    "area": "api_docs",
    "text": "\u251c\u2500\u2500 docs/                   # Documentation",
    "file": "README.md",
    "line": 78
  },
  {
    "area": "api_docs",
    "text": "\u2502   \u251c\u2500\u2500 tutorials/          # Step-by-step tutorials",
    "file": "README.md",
    "line": 79
  },
  {
    "area": "plasticity",
    "text": "\u2502   \u2502   \u251c\u2500\u2500 03_learning_plasticity.md",
    "file": "README.md",
    "line": 82
  },
  {
    "area": "edge_features",
    "text": "\u2502   \u2502   \u2514\u2500\u2500 05_edge_deployment.md",
    "file": "README.md",
    "line": 83
  },
  {
    "area": "api_docs",
    "text": "\u2502   \u251c\u2500\u2500 API_REFERENCE.md    # API documentation",
    "file": "README.md",
    "line": 84
  },
  {
    "area": "edge_features",
    "text": "\u2502   \u251c\u2500\u2500 jetson_optimization.py # Jetson optimization",
    "file": "README.md",
    "line": 88
  },
  {
    "area": "visualization_monitoring",
    "text": "- NumPy, SciPy, Matplotlib",
    "file": "README.md",
    "line": 98
  },
  {
    "area": "edge_features",
    "text": "- (Optional) NVIDIA Jetson Nano for edge deployment",
    "file": "README.md",
    "line": 100
  },
  {
    "area": "edge_features",
    "text": "pip install -e \".[jetson]\"    # For Jetson Nano",
    "file": "README.md",
    "line": 117
  },
  {
    "area": "neuron_models",
    "text": "### Neuron Models",
    "file": "README.md",
    "line": 136
  },
  {
    "area": "neuron_models",
    "text": "The system implements multiple biologically plausible neuron models:",
    "file": "README.md",
    "line": 138
  },
  {
    "area": "neuron_models",
    "text": "1. **Leaky Integrate-and-Fire (LIF)** - Simple, computationally efficient",
    "file": "README.md",
    "line": 140
  },
  {
    "area": "neuron_models",
    "text": "2. **Izhikevich** - Rich dynamics with low computational cost",
    "file": "README.md",
    "line": 141
  },
  {
    "area": "neuron_models",
    "text": "3. **Adaptive Exponential (AdEx)** - Spike frequency adaptation",
    "file": "README.md",
    "line": 142
  },
  {
    "area": "neuron_models",
    "text": "4. **Hodgkin-Huxley** - Detailed biophysical model with ion channels",
    "file": "README.md",
    "line": 143
  },
  {
    "area": "performance",
    "text": "Each model offers different trade-offs between biological realism and computational efficiency.",
    "file": "README.md",
    "line": 145
  },
  {
    "area": "plasticity",
    "text": "### Synaptic Plasticity",
    "file": "README.md",
    "line": 147
  },
  {
    "area": "plasticity",
    "text": "1. **STDP** - Spike-timing dependent plasticity for Hebbian learning",
    "file": "README.md",
    "line": 149
  },
  {
    "area": "plasticity",
    "text": "2. **STP** - Short-term plasticity with depression/facilitation",
    "file": "README.md",
    "line": 150
  },
  {
    "area": "neuromodulation",
    "text": "3. **Reward-Modulated** - Three-factor learning with neuromodulation",
    "file": "README.md",
    "line": 151
  },
  {
    "area": "plasticity",
    "text": "4. **Homeostatic** - Synaptic scaling and intrinsic plasticity",
    "file": "README.md",
    "line": 152
  },
  {
    "area": "simulation_modes",
    "text": "### Simulation Modes",
    "file": "README.md",
    "line": 155
  },
  {
    "area": "simulation_modes",
    "text": "2. **Event-Driven Mode** - Efficient processing of sparse activity",
    "file": "README.md",
    "line": 158
  },
  {
    "area": "edge_features",
    "text": "4. **Edge Optimization** - Specialized modes for embedded devices",
    "file": "README.md",
    "line": 160
  },
  {
    "area": "edge_features",
    "text": "### Edge AI",
    "file": "README.md",
    "line": 169
  },
  {
    "area": "performance",
    "text": "- Real-time pattern recognition",
    "file": "README.md",
    "line": 170
  },
  {
    "area": "edge_features",
    "text": "- Low-power inference",
    "file": "README.md",
    "line": 172
  },
  {
    "area": "neuron_models",
    "text": "### Neuron Models (`core/neurons.py`)",
    "file": "README.md",
    "line": 186
  },
  {
    "area": "neuron_models",
    "text": "# Create AdEx neuron",
    "file": "README.md",
    "line": 191
  },
  {
    "area": "simulation_modes",
    "text": "# Step simulation",
    "file": "README.md",
    "line": 203
  },
  {
    "area": "plasticity",
    "text": "from core.synapses import STDP_Synapse",
    "file": "README.md",
    "line": 210
  },
  {
    "area": "plasticity",
    "text": "# Create STDP synapse",
    "file": "README.md",
    "line": 212
  },
  {
    "area": "plasticity",
    "text": "synapse = STDP_Synapse(",
    "file": "README.md",
    "line": 213
  },
  {
    "area": "plasticity",
    "text": "tau_stdp=20.0,",
    "file": "README.md",
    "line": 218
  },
  {
    "area": "simulation_modes",
    "text": "# Run simulation",
    "file": "README.md",
    "line": 245
  },
  {
    "area": "simulation_modes",
    "text": "results = network.run_simulation(duration=100.0, dt=0.1)",
    "file": "README.md",
    "line": 246
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import RetinalEncoder",
    "file": "README.md",
    "line": 252
  },
  {
    "area": "sensory_encoding",
    "text": "# Create visual encoder",
    "file": "README.md",
    "line": 254
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = RetinalEncoder(resolution=(32, 32))",
    "file": "README.md",
    "line": 255
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(image)",
    "file": "README.md",
    "line": 259
  },
  {
    "area": "neuromodulation",
    "text": "- Reward-modulated learning",
    "file": "README.md",
    "line": 280
  },
  {
    "area": "visualization_monitoring",
    "text": "- Performance monitoring",
    "file": "README.md",
    "line": 282
  },
  {
    "area": "performance",
    "text": "- Real-time adaptation",
    "file": "README.md",
    "line": 283
  },
  {
    "area": "edge_features",
    "text": "### 3. Jetson Nano Demo",
    "file": "README.md",
    "line": 285
  },
  {
    "area": "edge_features",
    "text": "python demo/jetson_demo.py",
    "file": "README.md",
    "line": 287
  },
  {
    "area": "performance",
    "text": "- Real-time inference",
    "file": "README.md",
    "line": 292
  },
  {
    "area": "visualization_monitoring",
    "text": "- Performance monitoring",
    "file": "README.md",
    "line": 294
  },
  {
    "area": "edge_features",
    "text": "## \ud83d\ude80 Jetson Nano Deployment",
    "file": "README.md",
    "line": 296
  },
  {
    "area": "edge_features",
    "text": "The system is fully optimized for NVIDIA Jetson Nano deployment:",
    "file": "README.md",
    "line": 298
  },
  {
    "area": "edge_features",
    "text": "### Quick Jetson Setup",
    "file": "README.md",
    "line": 300
  },
  {
    "area": "edge_features",
    "text": "# Run Jetson optimization test",
    "file": "README.md",
    "line": 303
  },
  {
    "area": "edge_features",
    "text": "python jetson_optimization.py",
    "file": "README.md",
    "line": 304
  },
  {
    "area": "edge_features",
    "text": "# Run Jetson demo",
    "file": "README.md",
    "line": 306
  },
  {
    "area": "edge_features",
    "text": "python demo/jetson_demo.py",
    "file": "README.md",
    "line": 307
  },
  {
    "area": "edge_features",
    "text": "| Metric | Desktop | Jetson Nano | Optimization |",
    "file": "README.md",
    "line": 312
  },
  {
    "area": "performance",
    "text": "| **Inference Time** | 0.1s | 0.1-0.5s | Real-time capable |",
    "file": "README.md",
    "line": 316
  },
  {
    "area": "performance",
    "text": "| **Memory Usage** | 4-8GB | 2-4GB | 50% reduction |",
    "file": "README.md",
    "line": 317
  },
  {
    "area": "edge_features",
    "text": "| **Power Consumption** | 50-100W | 5-10W | 90% reduction |",
    "file": "README.md",
    "line": 318
  },
  {
    "area": "edge_features",
    "text": "See `JETSON_DEPLOYMENT.md` for complete deployment guide.",
    "file": "README.md",
    "line": 320
  },
  {
    "area": "neuron_models",
    "text": "# Test neuron models",
    "file": "README.md",
    "line": 331
  },
  {
    "area": "neuromodulation",
    "text": "- Network stability: Homeostatic regulation",
    "file": "README.md",
    "line": 346
  },
  {
    "area": "performance",
    "text": "### Computational Efficiency",
    "file": "README.md",
    "line": 348
  },
  {
    "area": "performance",
    "text": "- Memory usage: 1KB per neuron, 100B per synapse",
    "file": "README.md",
    "line": 349
  },
  {
    "area": "simulation_modes",
    "text": "- Simulation speed: 1000x real-time (desktop)",
    "file": "README.md",
    "line": 350
  },
  {
    "area": "performance",
    "text": "- Energy efficiency: 90% reduction vs traditional ANNs",
    "file": "README.md",
    "line": 351
  },
  {
    "area": "performance",
    "text": "### Scalability",
    "file": "README.md",
    "line": 353
  },
  {
    "area": "simulation_modes",
    "text": "'simulation_dt': 0.1,",
    "file": "README.md",
    "line": 366
  },
  {
    "area": "plasticity",
    "text": "'tau_stdp': 20.0,",
    "file": "README.md",
    "line": 380
  },
  {
    "area": "api_docs",
    "text": "## \ud83d\udcda Documentation",
    "file": "README.md",
    "line": 387
  },
  {
    "area": "api_docs",
    "text": "### Tutorials",
    "file": "README.md",
    "line": 389
  },
  {
    "area": "api_docs",
    "text": "- [**Getting Started**](docs/tutorials/01_getting_started.md) - Installation, first network, basic concepts",
    "file": "README.md",
    "line": 392
  },
  {
    "area": "api_docs",
    "text": "- [**Sensory Encoding**](docs/tutorials/02_sensory_encoding.md) - Converting real-world data to spikes",
    "file": "README.md",
    "line": 393
  },
  {
    "area": "plasticity",
    "text": "- [**Learning & Plasticity**](docs/tutorials/03_learning_plasticity.md) - STDP, homeostasis, reinforcement learning",
    "file": "README.md",
    "line": 394
  },
  {
    "area": "edge_features",
    "text": "- [**Edge Deployment**](docs/tutorials/05_edge_deployment.md) - Jetson Nano and embedded systems",
    "file": "README.md",
    "line": 395
  },
  {
    "area": "api_docs",
    "text": "### Core Documentation",
    "file": "README.md",
    "line": 397
  },
  {
    "area": "api_docs",
    "text": "- [API Reference](docs/API_REFERENCE.md) - Complete API documentation",
    "file": "README.md",
    "line": 398
  },
  {
    "area": "performance",
    "text": "- [Performance Benchmarks](docs/benchmarks.md) - Speed and efficiency metrics",
    "file": "README.md",
    "line": 400
  },
  {
    "area": "edge_features",
    "text": "- [Jetson Deployment](JETSON_DEPLOYMENT.md) - Detailed Jetson Nano guide",
    "file": "README.md",
    "line": 401
  },
  {
    "area": "api_docs",
    "text": "black core/ api/ demo/ tests/",
    "file": "README.md",
    "line": 424
  },
  {
    "area": "edge_features",
    "text": "- NVIDIA Jetson platform",
    "file": "README.md",
    "line": 441
  },
  {
    "area": "api_docs",
    "text": "- Check the documentation",
    "file": "README.md",
    "line": 448
  },
  {
    "area": "edge_features",
    "text": "**Neuromorphic Programming System** - Bridging biological neuroscience and edge computing for the next generation of brain-inspired AI.",
    "file": "README.md",
    "line": 453
  },
  {
    "area": "api_docs",
    "text": "# API Reference",
    "file": "docs\\API_REFERENCE.md",
    "line": 1
  },
  {
    "area": "api_docs",
    "text": "Complete API documentation for the Neuromorphic Programming System.",
    "file": "docs\\API_REFERENCE.md",
    "line": 3
  },
  {
    "area": "api_docs",
    "text": "2. [High-Level API](#high-level-api)",
    "file": "docs\\API_REFERENCE.md",
    "line": 8
  },
  {
    "area": "neuron_models",
    "text": "3. [Neuron Models](#neuron-models)",
    "file": "docs\\API_REFERENCE.md",
    "line": 9
  },
  {
    "area": "edge_features",
    "text": "8. [Jetson Optimization](#jetson-optimization)",
    "file": "docs\\API_REFERENCE.md",
    "line": 14
  },
  {
    "area": "api_docs",
    "text": "### NeuromorphicAPI",
    "file": "docs\\API_REFERENCE.md",
    "line": 18
  },
  {
    "area": "api_docs",
    "text": "from api.neuromorphic_api import NeuromorphicAPI",
    "file": "docs\\API_REFERENCE.md",
    "line": 23
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\API_REFERENCE.md",
    "line": 25
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\API_REFERENCE.md",
    "line": 34
  },
  {
    "area": "sensory_encoding",
    "text": "- `encoding_type` (str): Encoding type (\"rate\", \"retinal\", \"cochlear\", \"somatosensory\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 43
  },
  {
    "area": "sensory_encoding",
    "text": "api.add_sensory_layer(\"visual_input\", 64, \"retinal\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 46
  },
  {
    "area": "sensory_encoding",
    "text": "api.add_sensory_layer(\"auditory_input\", 32, \"cochlear\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 47
  },
  {
    "area": "neuron_models",
    "text": "- `neuron_type` (str): Neuron model (\"adex\", \"hh\", \"lif\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 56
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"hidden\", 32, \"adex\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 59
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"motor_output\", 8)",
    "file": "docs\\API_REFERENCE.md",
    "line": 70
  },
  {
    "area": "plasticity",
    "text": "- `synapse_type` (str): Synapse model (\"stdp\", \"stp\", \"neuromodulatory\", \"rstdp\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 80
  },
  {
    "area": "plasticity",
    "text": "api.connect_layers(\"input\", \"hidden\", \"feedforward\", synapse_type=\"stdp\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 84
  },
  {
    "area": "simulation_modes",
    "text": "##### `run_simulation(duration, dt=0.1, external_inputs=None)`",
    "file": "docs\\API_REFERENCE.md",
    "line": 87
  },
  {
    "area": "simulation_modes",
    "text": "Runs a network simulation.",
    "file": "docs\\API_REFERENCE.md",
    "line": 88
  },
  {
    "area": "simulation_modes",
    "text": "- `duration` (float): Simulation duration in milliseconds",
    "file": "docs\\API_REFERENCE.md",
    "line": 91
  },
  {
    "area": "simulation_modes",
    "text": "- `dt` (float): Time step in milliseconds",
    "file": "docs\\API_REFERENCE.md",
    "line": 92
  },
  {
    "area": "simulation_modes",
    "text": "- `dict`: Simulation results with spike times and network state",
    "file": "docs\\API_REFERENCE.md",
    "line": 96
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(100.0, external_inputs={\"input\": [(i, i*10.0) for i in range(20)]})",
    "file": "docs\\API_REFERENCE.md",
    "line": 99
  },
  {
    "area": "api_docs",
    "text": "training_results = api.train_sensorimotor_system(training_data, epochs=50)",
    "file": "docs\\API_REFERENCE.md",
    "line": 113
  },
  {
    "area": "api_docs",
    "text": "info = api.get_network_info()",
    "file": "docs\\API_REFERENCE.md",
    "line": 123
  },
  {
    "area": "neuron_models",
    "text": "## Neuron Models",
    "file": "docs\\API_REFERENCE.md",
    "line": 127
  },
  {
    "area": "neuron_models",
    "text": "Biologically realistic neuron model with spike frequency adaptation.",
    "file": "docs\\API_REFERENCE.md",
    "line": 131
  },
  {
    "area": "simulation_modes",
    "text": "Advances neuron state by one time step.",
    "file": "docs\\API_REFERENCE.md",
    "line": 162
  },
  {
    "area": "simulation_modes",
    "text": "- `dt` (float): Time step (ms)",
    "file": "docs\\API_REFERENCE.md",
    "line": 165
  },
  {
    "area": "neuron_models",
    "text": "### HodgkinHuxleyNeuron",
    "file": "docs\\API_REFERENCE.md",
    "line": 177
  },
  {
    "area": "neuron_models",
    "text": "Full ion channel dynamics neuron model.",
    "file": "docs\\API_REFERENCE.md",
    "line": 179
  },
  {
    "area": "neuron_models",
    "text": "from core.neurons import HodgkinHuxleyNeuron",
    "file": "docs\\API_REFERENCE.md",
    "line": 182
  },
  {
    "area": "neuron_models",
    "text": "neuron = HodgkinHuxleyNeuron(",
    "file": "docs\\API_REFERENCE.md",
    "line": 184
  },
  {
    "area": "neuron_models",
    "text": "Simplified but efficient neuron model.",
    "file": "docs\\API_REFERENCE.md",
    "line": 195
  },
  {
    "area": "plasticity",
    "text": "### STDP_Synapse",
    "file": "docs\\API_REFERENCE.md",
    "line": 211
  },
  {
    "area": "plasticity",
    "text": "Spike-timing-dependent plasticity synapse.",
    "file": "docs\\API_REFERENCE.md",
    "line": 213
  },
  {
    "area": "plasticity",
    "text": "from core.synapses import STDP_Synapse",
    "file": "docs\\API_REFERENCE.md",
    "line": 216
  },
  {
    "area": "plasticity",
    "text": "synapse = STDP_Synapse(",
    "file": "docs\\API_REFERENCE.md",
    "line": 218
  },
  {
    "area": "plasticity",
    "text": "tau_stdp=20.0,",
    "file": "docs\\API_REFERENCE.md",
    "line": 224
  },
  {
    "area": "plasticity",
    "text": "- `tau_stdp` (float): STDP time constant (ms)",
    "file": "docs\\API_REFERENCE.md",
    "line": 239
  },
  {
    "area": "plasticity",
    "text": "### RSTDP_Synapse",
    "file": "docs\\API_REFERENCE.md",
    "line": 268
  },
  {
    "area": "plasticity",
    "text": "Reward-modulated STDP synapse.",
    "file": "docs\\API_REFERENCE.md",
    "line": 270
  },
  {
    "area": "plasticity",
    "text": "from core.synapses import RSTDP_Synapse",
    "file": "docs\\API_REFERENCE.md",
    "line": 273
  },
  {
    "area": "plasticity",
    "text": "synapse = RSTDP_Synapse(",
    "file": "docs\\API_REFERENCE.md",
    "line": 275
  },
  {
    "area": "neuromodulation",
    "text": "##### `update_reward(reward)`",
    "file": "docs\\API_REFERENCE.md",
    "line": 293
  },
  {
    "area": "neuromodulation",
    "text": "Updates reward signal.",
    "file": "docs\\API_REFERENCE.md",
    "line": 294
  },
  {
    "area": "neuromodulation",
    "text": "synapse.update_reward(reward=1.0)",
    "file": "docs\\API_REFERENCE.md",
    "line": 297
  },
  {
    "area": "plasticity",
    "text": "### ShortTermPlasticitySynapse",
    "file": "docs\\API_REFERENCE.md",
    "line": 300
  },
  {
    "area": "plasticity",
    "text": "Synapse with short-term plasticity.",
    "file": "docs\\API_REFERENCE.md",
    "line": 302
  },
  {
    "area": "plasticity",
    "text": "from core.synapses import ShortTermPlasticitySynapse",
    "file": "docs\\API_REFERENCE.md",
    "line": 305
  },
  {
    "area": "plasticity",
    "text": "synapse = ShortTermPlasticitySynapse(",
    "file": "docs\\API_REFERENCE.md",
    "line": 307
  },
  {
    "area": "simulation_modes",
    "text": "##### `run_simulation(duration, dt)`",
    "file": "docs\\API_REFERENCE.md",
    "line": 349
  },
  {
    "area": "simulation_modes",
    "text": "Runs network simulation.",
    "file": "docs\\API_REFERENCE.md",
    "line": 350
  },
  {
    "area": "simulation_modes",
    "text": "results = network.run_simulation(duration=100.0, dt=0.1)",
    "file": "docs\\API_REFERENCE.md",
    "line": 353
  },
  {
    "area": "neuron_models",
    "text": "builder.add_processing_layer(\"hidden\", 25, \"adex\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 365
  },
  {
    "area": "sensory_encoding",
    "text": "### RetinalEncoder",
    "file": "docs\\API_REFERENCE.md",
    "line": 374
  },
  {
    "area": "sensory_encoding",
    "text": "Visual encoding with retinal-like processing.",
    "file": "docs\\API_REFERENCE.md",
    "line": 376
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import RetinalEncoder",
    "file": "docs\\API_REFERENCE.md",
    "line": 379
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = RetinalEncoder(resolution=(32, 32))",
    "file": "docs\\API_REFERENCE.md",
    "line": 381
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(image)",
    "file": "docs\\API_REFERENCE.md",
    "line": 382
  },
  {
    "area": "sensory_encoding",
    "text": "### CochlearEncoder",
    "file": "docs\\API_REFERENCE.md",
    "line": 385
  },
  {
    "area": "sensory_encoding",
    "text": "Auditory encoding with cochlear-like processing.",
    "file": "docs\\API_REFERENCE.md",
    "line": 387
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import CochlearEncoder",
    "file": "docs\\API_REFERENCE.md",
    "line": 390
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = CochlearEncoder(frequency_bands=64)",
    "file": "docs\\API_REFERENCE.md",
    "line": 392
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(audio_signal)",
    "file": "docs\\API_REFERENCE.md",
    "line": 393
  },
  {
    "area": "sensory_encoding",
    "text": "### SomatosensoryEncoder",
    "file": "docs\\API_REFERENCE.md",
    "line": 396
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import SomatosensoryEncoder",
    "file": "docs\\API_REFERENCE.md",
    "line": 401
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = SomatosensoryEncoder(sensor_grid=(16, 16))",
    "file": "docs\\API_REFERENCE.md",
    "line": 403
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(pressure_map)",
    "file": "docs\\API_REFERENCE.md",
    "line": 404
  },
  {
    "area": "sensory_encoding",
    "text": "### MultiModalEncoder",
    "file": "docs\\API_REFERENCE.md",
    "line": 407
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import MultiModalEncoder",
    "file": "docs\\API_REFERENCE.md",
    "line": 412
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = MultiModalEncoder({",
    "file": "docs\\API_REFERENCE.md",
    "line": 414
  },
  {
    "area": "sensory_encoding",
    "text": "'vision': RetinalEncoder(resolution=(32, 32)),",
    "file": "docs\\API_REFERENCE.md",
    "line": 415
  },
  {
    "area": "sensory_encoding",
    "text": "'auditory': CochlearEncoder(frequency_bands=64),",
    "file": "docs\\API_REFERENCE.md",
    "line": 416
  },
  {
    "area": "sensory_encoding",
    "text": "'tactile': SomatosensoryEncoder(sensor_grid=(16, 16))",
    "file": "docs\\API_REFERENCE.md",
    "line": 417
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(inputs)",
    "file": "docs\\API_REFERENCE.md",
    "line": 425
  },
  {
    "area": "neuromodulation",
    "text": "### NeuromodulatoryController",
    "file": "docs\\API_REFERENCE.md",
    "line": 430
  },
  {
    "area": "neuromodulation",
    "text": "Manages neuromodulatory systems.",
    "file": "docs\\API_REFERENCE.md",
    "line": 432
  },
  {
    "area": "neuromodulation",
    "text": "from core.neuromodulation import NeuromodulatoryController",
    "file": "docs\\API_REFERENCE.md",
    "line": 435
  },
  {
    "area": "neuromodulation",
    "text": "controller = NeuromodulatoryController()",
    "file": "docs\\API_REFERENCE.md",
    "line": 437
  },
  {
    "area": "neuromodulation",
    "text": "##### `update(sensory_input, reward, expected_reward, **kwargs)`",
    "file": "docs\\API_REFERENCE.md",
    "line": 442
  },
  {
    "area": "neuromodulation",
    "text": "Updates neuromodulatory systems.",
    "file": "docs\\API_REFERENCE.md",
    "line": 443
  },
  {
    "area": "neuromodulation",
    "text": "reward=1.0,",
    "file": "docs\\API_REFERENCE.md",
    "line": 448
  },
  {
    "area": "neuromodulation",
    "text": "expected_reward=0.5,",
    "file": "docs\\API_REFERENCE.md",
    "line": 449
  },
  {
    "area": "neuromodulation",
    "text": "print(f\"Dopamine: {levels[NeuromodulatorType.DOPAMINE]}\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 463
  },
  {
    "area": "edge_features",
    "text": "## Jetson Optimization",
    "file": "docs\\API_REFERENCE.md",
    "line": 492
  },
  {
    "area": "edge_features",
    "text": "### JetsonOptimizer",
    "file": "docs\\API_REFERENCE.md",
    "line": 494
  },
  {
    "area": "edge_features",
    "text": "Optimizes networks for Jetson Nano deployment.",
    "file": "docs\\API_REFERENCE.md",
    "line": 496
  },
  {
    "area": "edge_features",
    "text": "from jetson_optimization import JetsonOptimizer",
    "file": "docs\\API_REFERENCE.md",
    "line": 499
  },
  {
    "area": "edge_features",
    "text": "optimizer = JetsonOptimizer()",
    "file": "docs\\API_REFERENCE.md",
    "line": 501
  },
  {
    "area": "edge_features",
    "text": "Gets Jetson system information.",
    "file": "docs\\API_REFERENCE.md",
    "line": 507
  },
  {
    "area": "performance",
    "text": "print(f\"Memory: {info['memory_available'] / (1024**3):.2f} GB\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 512
  },
  {
    "area": "edge_features",
    "text": "Optimizes network size for Jetson constraints.",
    "file": "docs\\API_REFERENCE.md",
    "line": 517
  },
  {
    "area": "edge_features",
    "text": "### JetsonSensorimotorSystem",
    "file": "docs\\API_REFERENCE.md",
    "line": 527
  },
  {
    "area": "edge_features",
    "text": "Jetson-optimized sensorimotor system.",
    "file": "docs\\API_REFERENCE.md",
    "line": 529
  },
  {
    "area": "edge_features",
    "text": "from jetson_optimization import JetsonSensorimotorSystem",
    "file": "docs\\API_REFERENCE.md",
    "line": 532
  },
  {
    "area": "edge_features",
    "text": "system = JetsonSensorimotorSystem(use_gpu=True)",
    "file": "docs\\API_REFERENCE.md",
    "line": 534
  },
  {
    "area": "edge_features",
    "text": "Runs inference on Jetson Nano.",
    "file": "docs\\API_REFERENCE.md",
    "line": 541
  },
  {
    "area": "simulation_modes",
    "text": "Simulation results contain:",
    "file": "docs\\API_REFERENCE.md",
    "line": 573
  },
  {
    "area": "neuromodulation",
    "text": "'reward': 1.0",
    "file": "docs\\API_REFERENCE.md",
    "line": 601
  },
  {
    "area": "simulation_modes",
    "text": "api.run_simulation(100.0)",
    "file": "docs\\API_REFERENCE.md",
    "line": 612
  },
  {
    "area": "simulation_modes",
    "text": "print(f\"Simulation error: {e}\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 616
  },
  {
    "area": "edge_features",
    "text": "### Jetson-Specific Errors",
    "file": "docs\\API_REFERENCE.md",
    "line": 619
  },
  {
    "area": "performance",
    "text": "except MemoryError:",
    "file": "docs\\API_REFERENCE.md",
    "line": 624
  },
  {
    "area": "edge_features",
    "text": "print(\"Insufficient memory on Jetson\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 625
  },
  {
    "area": "performance",
    "text": "### Memory Optimization",
    "file": "docs\\API_REFERENCE.md",
    "line": 632
  },
  {
    "area": "performance",
    "text": "# Monitor memory usage",
    "file": "docs\\API_REFERENCE.md",
    "line": 643
  },
  {
    "area": "performance",
    "text": "memory = psutil.virtual_memory()",
    "file": "docs\\API_REFERENCE.md",
    "line": 645
  },
  {
    "area": "performance",
    "text": "print(f\"Memory usage: {memory.percent}%\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 646
  },
  {
    "area": "edge_features",
    "text": "### Jetson Optimization",
    "file": "docs\\API_REFERENCE.md",
    "line": 649
  },
  {
    "area": "edge_features",
    "text": "# Reduce network size for Jetson",
    "file": "docs\\API_REFERENCE.md",
    "line": 652
  },
  {
    "area": "api_docs",
    "text": "from api.neuromorphic_api import NeuromorphicAPI",
    "file": "docs\\API_REFERENCE.md",
    "line": 669
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\API_REFERENCE.md",
    "line": 672
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\API_REFERENCE.md",
    "line": 673
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"input\", 50, \"rate\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 676
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"hidden\", 25, \"adex\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 677
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"output\", 10)",
    "file": "docs\\API_REFERENCE.md",
    "line": 678
  },
  {
    "area": "plasticity",
    "text": "api.connect_layers(\"input\", \"hidden\", \"feedforward\", synapse_type=\"stdp\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 681
  },
  {
    "area": "plasticity",
    "text": "api.connect_layers(\"hidden\", \"output\", \"feedforward\", synapse_type=\"stdp\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 682
  },
  {
    "area": "simulation_modes",
    "text": "# Run simulation",
    "file": "docs\\API_REFERENCE.md",
    "line": 684
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(100.0)",
    "file": "docs\\API_REFERENCE.md",
    "line": 685
  },
  {
    "area": "edge_features",
    "text": "### Jetson Deployment Example",
    "file": "docs\\API_REFERENCE.md",
    "line": 692
  },
  {
    "area": "edge_features",
    "text": "from jetson_optimization import JetsonSensorimotorSystem",
    "file": "docs\\API_REFERENCE.md",
    "line": 695
  },
  {
    "area": "edge_features",
    "text": "# Initialize Jetson system",
    "file": "docs\\API_REFERENCE.md",
    "line": 697
  },
  {
    "area": "edge_features",
    "text": "system = JetsonSensorimotorSystem(use_gpu=True)",
    "file": "docs\\API_REFERENCE.md",
    "line": 698
  },
  {
    "area": "edge_features",
    "text": "metrics = results.get('jetson_metrics', {})",
    "file": "docs\\API_REFERENCE.md",
    "line": 711
  },
  {
    "area": "performance",
    "text": "print(f\"Memory: {metrics.get('current_memory', 0):.1f}%\")",
    "file": "docs\\API_REFERENCE.md",
    "line": 713
  },
  {
    "area": "api_docs",
    "text": "\u2502                    API Layer                               \u2502",
    "file": "docs\\ARCHITECTURE.md",
    "line": 15
  },
  {
    "area": "edge_features",
    "text": "\u2502  \u2502Neuromorphic \u2502 \u2502Sensorimotor \u2502 \u2502Jetson       \u2502         \u2502",
    "file": "docs\\ARCHITECTURE.md",
    "line": 17
  },
  {
    "area": "api_docs",
    "text": "\u2502  \u2502API          \u2502 \u2502System       \u2502 \u2502Optimization \u2502         \u2502",
    "file": "docs\\ARCHITECTURE.md",
    "line": 18
  },
  {
    "area": "simulation_modes",
    "text": "\u2502  \u2502Encoding     \u2502 \u2502Neuromodul.  \u2502 \u2502Simulation   \u2502         \u2502",
    "file": "docs\\ARCHITECTURE.md",
    "line": 26
  },
  {
    "area": "performance",
    "text": "\u2502  \u2502CPU/GPU      \u2502 \u2502Memory       \u2502 \u2502I/O          \u2502         \u2502",
    "file": "docs\\ARCHITECTURE.md",
    "line": 31
  },
  {
    "area": "neuron_models",
    "text": "### 1. Neuron Models (`core/neurons.py`)",
    "file": "docs\\ARCHITECTURE.md",
    "line": 39
  },
  {
    "area": "neuron_models",
    "text": "The neuron models implement biologically plausible neural dynamics:",
    "file": "docs\\ARCHITECTURE.md",
    "line": 41
  },
  {
    "area": "neuron_models",
    "text": "Adaptive Exponential Integrate-and-Fire neuron model.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 47
  },
  {
    "area": "neuron_models",
    "text": "#### HodgkinHuxleyNeuron",
    "file": "docs\\ARCHITECTURE.md",
    "line": 61
  },
  {
    "area": "neuron_models",
    "text": "class HodgkinHuxleyNeuron(NeuronModel):",
    "file": "docs\\ARCHITECTURE.md",
    "line": 63
  },
  {
    "area": "neuron_models",
    "text": "Hodgkin-Huxley neuron with full ion channel dynamics.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 65
  },
  {
    "area": "neuron_models",
    "text": "Leaky Integrate-and-Fire neuron for efficient simulation.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 82
  },
  {
    "area": "performance",
    "text": "- Computational efficiency",
    "file": "docs\\ARCHITECTURE.md",
    "line": 90
  },
  {
    "area": "simulation_modes",
    "text": "- Large-scale simulation capability",
    "file": "docs\\ARCHITECTURE.md",
    "line": 91
  },
  {
    "area": "performance",
    "text": "- Memory-efficient implementation",
    "file": "docs\\ARCHITECTURE.md",
    "line": 93
  },
  {
    "area": "plasticity",
    "text": "Synapse models implement various forms of synaptic plasticity:",
    "file": "docs\\ARCHITECTURE.md",
    "line": 97
  },
  {
    "area": "plasticity",
    "text": "#### STDP_Synapse",
    "file": "docs\\ARCHITECTURE.md",
    "line": 99
  },
  {
    "area": "plasticity",
    "text": "class STDP_Synapse(SynapseModel):",
    "file": "docs\\ARCHITECTURE.md",
    "line": 101
  },
  {
    "area": "plasticity",
    "text": "Spike-Timing-Dependent Plasticity synapse.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 103
  },
  {
    "area": "plasticity",
    "text": "- Hebbian learning based on spike timing",
    "file": "docs\\ARCHITECTURE.md",
    "line": 112
  },
  {
    "area": "plasticity",
    "text": "#### RSTDP_Synapse",
    "file": "docs\\ARCHITECTURE.md",
    "line": 117
  },
  {
    "area": "plasticity",
    "text": "class RSTDP_Synapse(STDP_Synapse):",
    "file": "docs\\ARCHITECTURE.md",
    "line": 119
  },
  {
    "area": "plasticity",
    "text": "Reward-modulated STDP synapse.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 121
  },
  {
    "area": "neuromodulation",
    "text": "Combines timing-based learning with reward signals:",
    "file": "docs\\ARCHITECTURE.md",
    "line": 123
  },
  {
    "area": "neuromodulation",
    "text": "\u0394w = (A_+ * exp(-\u0394t/\u03c4_+) + reward_modulation) for \u0394t > 0",
    "file": "docs\\ARCHITECTURE.md",
    "line": 124
  },
  {
    "area": "neuromodulation",
    "text": "- Reward-modulated learning",
    "file": "docs\\ARCHITECTURE.md",
    "line": 129
  },
  {
    "area": "neuromodulation",
    "text": "- Neuromodulatory influences",
    "file": "docs\\ARCHITECTURE.md",
    "line": 130
  },
  {
    "area": "plasticity",
    "text": "#### ShortTermPlasticitySynapse",
    "file": "docs\\ARCHITECTURE.md",
    "line": 134
  },
  {
    "area": "plasticity",
    "text": "class ShortTermPlasticitySynapse(SynapseModel):",
    "file": "docs\\ARCHITECTURE.md",
    "line": 136
  },
  {
    "area": "plasticity",
    "text": "Short-term plasticity with depression and facilitation.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 138
  },
  {
    "area": "api_docs",
    "text": "- Rapid adaptation to input patterns",
    "file": "docs\\ARCHITECTURE.md",
    "line": 149
  },
  {
    "area": "simulation_modes",
    "text": "- Event-driven simulation",
    "file": "docs\\ARCHITECTURE.md",
    "line": 165
  },
  {
    "area": "visualization_monitoring",
    "text": "- Performance monitoring",
    "file": "docs\\ARCHITECTURE.md",
    "line": 166
  },
  {
    "area": "simulation_modes",
    "text": "- Event-driven simulation engine",
    "file": "docs\\ARCHITECTURE.md",
    "line": 173
  },
  {
    "area": "visualization_monitoring",
    "text": "- Performance monitoring and optimization",
    "file": "docs\\ARCHITECTURE.md",
    "line": 174
  },
  {
    "area": "performance",
    "text": "- Memory-efficient data structures",
    "file": "docs\\ARCHITECTURE.md",
    "line": 175
  },
  {
    "area": "edge_features",
    "text": "- Resource management",
    "file": "docs\\ARCHITECTURE.md",
    "line": 187
  },
  {
    "area": "edge_features",
    "text": "- Resource constraint management",
    "file": "docs\\ARCHITECTURE.md",
    "line": 194
  },
  {
    "area": "sensory_encoding",
    "text": "#### RetinalEncoder",
    "file": "docs\\ARCHITECTURE.md",
    "line": 201
  },
  {
    "area": "sensory_encoding",
    "text": "class RetinalEncoder(SensoryEncoder):",
    "file": "docs\\ARCHITECTURE.md",
    "line": 203
  },
  {
    "area": "sensory_encoding",
    "text": "Visual encoding with retinal-like processing.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 205
  },
  {
    "area": "sensory_encoding",
    "text": "- Retinal-like receptive fields",
    "file": "docs\\ARCHITECTURE.md",
    "line": 216
  },
  {
    "area": "sensory_encoding",
    "text": "#### CochlearEncoder",
    "file": "docs\\ARCHITECTURE.md",
    "line": 221
  },
  {
    "area": "sensory_encoding",
    "text": "class CochlearEncoder(SensoryEncoder):",
    "file": "docs\\ARCHITECTURE.md",
    "line": 223
  },
  {
    "area": "sensory_encoding",
    "text": "Auditory encoding with cochlear-like processing.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 225
  },
  {
    "area": "sensory_encoding",
    "text": "#### MultiModalEncoder",
    "file": "docs\\ARCHITECTURE.md",
    "line": 241
  },
  {
    "area": "sensory_encoding",
    "text": "class MultiModalEncoder(SensoryEncoder):",
    "file": "docs\\ARCHITECTURE.md",
    "line": 243
  },
  {
    "area": "neuromodulation",
    "text": "Neuromodulatory systems implement realistic neurotransmitter dynamics:",
    "file": "docs\\ARCHITECTURE.md",
    "line": 263
  },
  {
    "area": "neuromodulation",
    "text": "#### NeuromodulatoryController",
    "file": "docs\\ARCHITECTURE.md",
    "line": 265
  },
  {
    "area": "neuromodulation",
    "text": "class NeuromodulatoryController:",
    "file": "docs\\ARCHITECTURE.md",
    "line": 267
  },
  {
    "area": "neuromodulation",
    "text": "Central controller for neuromodulatory systems.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 269
  },
  {
    "area": "neuromodulation",
    "text": "- Dopaminergic system",
    "file": "docs\\ARCHITECTURE.md",
    "line": 272
  },
  {
    "area": "neuromodulation",
    "text": "- Four major neuromodulatory systems",
    "file": "docs\\ARCHITECTURE.md",
    "line": 280
  },
  {
    "area": "neuromodulation",
    "text": "class AdaptiveLearningController(NeuromodulatoryController):",
    "file": "docs\\ARCHITECTURE.md",
    "line": 287
  },
  {
    "area": "edge_features",
    "text": "- Resource-aware learning",
    "file": "docs\\ARCHITECTURE.md",
    "line": 294
  },
  {
    "area": "edge_features",
    "text": "- Resource-aware learning",
    "file": "docs\\ARCHITECTURE.md",
    "line": 302
  },
  {
    "area": "api_docs",
    "text": "## API Layer",
    "file": "docs\\ARCHITECTURE.md",
    "line": 305
  },
  {
    "area": "api_docs",
    "text": "### NeuromorphicAPI",
    "file": "docs\\ARCHITECTURE.md",
    "line": 307
  },
  {
    "area": "api_docs",
    "text": "class NeuromorphicAPI:",
    "file": "docs\\ARCHITECTURE.md",
    "line": 309
  },
  {
    "area": "api_docs",
    "text": "High-level API for neuromorphic system interaction.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 311
  },
  {
    "area": "simulation_modes",
    "text": "- Simulation execution",
    "file": "docs\\ARCHITECTURE.md",
    "line": 315
  },
  {
    "area": "visualization_monitoring",
    "text": "- Visualization tools",
    "file": "docs\\ARCHITECTURE.md",
    "line": 317
  },
  {
    "area": "neuron_models",
    "text": "- Simplified parameter configuration",
    "file": "docs\\ARCHITECTURE.md",
    "line": 323
  },
  {
    "area": "visualization_monitoring",
    "text": "- Built-in visualization tools",
    "file": "docs\\ARCHITECTURE.md",
    "line": 325
  },
  {
    "area": "visualization_monitoring",
    "text": "- Performance monitoring",
    "file": "docs\\ARCHITECTURE.md",
    "line": 337
  },
  {
    "area": "performance",
    "text": "- Real-time adaptation",
    "file": "docs\\ARCHITECTURE.md",
    "line": 344
  },
  {
    "area": "edge_features",
    "text": "### Jetson Optimization (`scripts/jetson_optimization.py`)",
    "file": "docs\\ARCHITECTURE.md",
    "line": 349
  },
  {
    "area": "edge_features",
    "text": "class JetsonOptimizer:",
    "file": "docs\\ARCHITECTURE.md",
    "line": 352
  },
  {
    "area": "edge_features",
    "text": "Jetson Nano optimization utilities.",
    "file": "docs\\ARCHITECTURE.md",
    "line": 354
  },
  {
    "area": "edge_features",
    "text": "- Resource constraint management",
    "file": "docs\\ARCHITECTURE.md",
    "line": 357
  },
  {
    "area": "visualization_monitoring",
    "text": "- Performance monitoring",
    "file": "docs\\ARCHITECTURE.md",
    "line": 358
  },
  {
    "area": "edge_features",
    "text": "- Power optimization",
    "file": "docs\\ARCHITECTURE.md",
    "line": 360
  },
  {
    "area": "edge_features",
    "text": "- Resource constraint management",
    "file": "docs\\ARCHITECTURE.md",
    "line": 365
  },
  {
    "area": "visualization_monitoring",
    "text": "- Performance monitoring",
    "file": "docs\\ARCHITECTURE.md",
    "line": 366
  },
  {
    "area": "edge_features",
    "text": "- Power optimization",
    "file": "docs\\ARCHITECTURE.md",
    "line": 368
  },
  {
    "area": "sensory_encoding",
    "text": "Sensors \u2192 Encoders \u2192 Neurons/Synapses \u2192 Effectors",
    "file": "docs\\ARCHITECTURE.md",
    "line": 377
  },
  {
    "area": "plasticity",
    "text": "Performance Feedback \u2192 Reward Signals \u2192 Neuromodulation \u2192 Synaptic Plasticity",
    "file": "docs\\ARCHITECTURE.md",
    "line": 392
  },
  {
    "area": "performance",
    "text": "## Memory Architecture",
    "file": "docs\\ARCHITECTURE.md",
    "line": 400
  },
  {
    "area": "performance",
    "text": "### Neuron Memory Layout",
    "file": "docs\\ARCHITECTURE.md",
    "line": 402
  },
  {
    "area": "performance",
    "text": "### Synapse Memory Layout",
    "file": "docs\\ARCHITECTURE.md",
    "line": 411
  },
  {
    "area": "performance",
    "text": "### Network Memory Management",
    "file": "docs\\ARCHITECTURE.md",
    "line": 420
  },
  {
    "area": "performance",
    "text": "Network Memory:",
    "file": "docs\\ARCHITECTURE.md",
    "line": 422
  },
  {
    "area": "simulation_modes",
    "text": "\u2514\u2500\u2500 Simulation state (5% of total)",
    "file": "docs\\ARCHITECTURE.md",
    "line": 426
  },
  {
    "area": "simulation_modes",
    "text": "- **Neuron updates**: O(n) per time step",
    "file": "docs\\ARCHITECTURE.md",
    "line": 432
  },
  {
    "area": "simulation_modes",
    "text": "- **Synapse updates**: O(s) per time step",
    "file": "docs\\ARCHITECTURE.md",
    "line": 433
  },
  {
    "area": "simulation_modes",
    "text": "- **Network simulation**: O(n + s) per time step",
    "file": "docs\\ARCHITECTURE.md",
    "line": 434
  },
  {
    "area": "performance",
    "text": "- **Memory usage**: O(n + s) total",
    "file": "docs\\ARCHITECTURE.md",
    "line": 435
  },
  {
    "area": "performance",
    "text": "### Scalability Limits",
    "file": "docs\\ARCHITECTURE.md",
    "line": 437
  },
  {
    "area": "edge_features",
    "text": "- **Jetson Nano**: 1,000 neurons, 10,000 synapses",
    "file": "docs\\ARCHITECTURE.md",
    "line": 439
  },
  {
    "area": "performance",
    "text": "- **Memory constraint**: 1KB per neuron, 100B per synapse",
    "file": "docs\\ARCHITECTURE.md",
    "line": 440
  },
  {
    "area": "simulation_modes",
    "text": "- **Time constraint**: Real-time simulation capability",
    "file": "docs\\ARCHITECTURE.md",
    "line": 441
  },
  {
    "area": "simulation_modes",
    "text": "- **Event-driven simulation**: Only process active neurons",
    "file": "docs\\ARCHITECTURE.md",
    "line": 444
  },
  {
    "area": "performance",
    "text": "- **Memory pooling**: Reuse memory for similar objects",
    "file": "docs\\ARCHITECTURE.md",
    "line": 446
  },
  {
    "area": "performance",
    "text": "2. **Memory errors**: Insufficient memory for network size",
    "file": "docs\\ARCHITECTURE.md",
    "line": 453
  },
  {
    "area": "simulation_modes",
    "text": "3. **Performance errors**: Simulation too slow for real-time",
    "file": "docs\\ARCHITECTURE.md",
    "line": 454
  },
  {
    "area": "performance",
    "text": "- **Memory monitoring**: Track and manage memory usage",
    "file": "docs\\ARCHITECTURE.md",
    "line": 459
  },
  {
    "area": "performance",
    "text": "- **Performance monitoring**: Real-time performance tracking",
    "file": "docs\\ARCHITECTURE.md",
    "line": 460
  },
  {
    "area": "performance",
    "text": "- **Memory safety**: Bounds checking and memory management",
    "file": "docs\\ARCHITECTURE.md",
    "line": 467
  },
  {
    "area": "edge_features",
    "text": "- **Resource limits**: Prevent resource exhaustion",
    "file": "docs\\ARCHITECTURE.md",
    "line": 471
  },
  {
    "area": "performance",
    "text": "- **Performance limits**: Maintain real-time operation",
    "file": "docs\\ARCHITECTURE.md",
    "line": 472
  },
  {
    "area": "plasticity",
    "text": "2. **Structural plasticity**: Dynamic synapse formation/elimination",
    "file": "docs\\ARCHITECTURE.md",
    "line": 479
  },
  {
    "area": "plasticity",
    "text": "3. **Meta-plasticity**: Higher-order learning rules",
    "file": "docs\\ARCHITECTURE.md",
    "line": 480
  },
  {
    "area": "performance",
    "text": "4. **Cognitive integration**: Working memory and attention",
    "file": "docs\\ARCHITECTURE.md",
    "line": 481
  },
  {
    "area": "simulation_modes",
    "text": "1. **Intel Loihi**: Event-driven neuromorphic hardware",
    "file": "docs\\ARCHITECTURE.md",
    "line": 484
  },
  {
    "area": "performance",
    "text": "### Scalability Improvements",
    "file": "docs\\ARCHITECTURE.md",
    "line": 489
  },
  {
    "area": "simulation_modes",
    "text": "1. **Distributed simulation**: Multi-node network simulation",
    "file": "docs\\ARCHITECTURE.md",
    "line": 490
  },
  {
    "area": "edge_features",
    "text": "3. **Edge computing**: Optimized for edge devices",
    "file": "docs\\ARCHITECTURE.md",
    "line": 492
  },
  {
    "area": "performance",
    "text": "4. **Real-time systems**: Hard real-time neuromorphic computing",
    "file": "docs\\ARCHITECTURE.md",
    "line": 493
  },
  {
    "area": "performance",
    "text": "![Throughput](https://img.shields.io/badge/Throughput-50K_neurons/sec-green)",
    "file": "docs\\benchmarks.md",
    "line": 7
  },
  {
    "area": "performance",
    "text": "![Memory](https://img.shields.io/badge/Memory-53MB-brightgreen)",
    "file": "docs\\benchmarks.md",
    "line": 8
  },
  {
    "area": "performance",
    "text": "### Step Throughput (neurons/sec)",
    "file": "docs\\benchmarks.md",
    "line": 13
  },
  {
    "area": "performance",
    "text": "| Network Size | Throughput (neurons/sec) | Performance |",
    "file": "docs\\benchmarks.md",
    "line": 15
  },
  {
    "area": "performance",
    "text": "### Memory Footprint",
    "file": "docs\\benchmarks.md",
    "line": 22
  },
  {
    "area": "performance",
    "text": "| Network Size | Memory Usage (MB) | Memory/Neuron (KB) |",
    "file": "docs\\benchmarks.md",
    "line": 24
  },
  {
    "area": "performance",
    "text": "### Convergence Speed",
    "file": "docs\\benchmarks.md",
    "line": 31
  },
  {
    "area": "neuromodulation",
    "text": "| Homeostatic Adaptation | Adaptation Speed | 0.0150 | Good |",
    "file": "docs\\benchmarks.md",
    "line": 37
  },
  {
    "area": "performance",
    "text": "Total Memory: 15.9 GB",
    "file": "docs\\benchmarks.md",
    "line": 46
  },
  {
    "area": "performance",
    "text": "- **Throughput Optimization**: Consider implementing vectorized operations",
    "file": "docs\\benchmarks.md",
    "line": 53
  },
  {
    "area": "performance",
    "text": "- **Memory Efficiency**: Current memory usage is acceptable",
    "file": "docs\\benchmarks.md",
    "line": 54
  },
  {
    "area": "performance",
    "text": "### 1. Step Throughput",
    "file": "docs\\benchmarks.md",
    "line": 77
  },
  {
    "area": "simulation_modes",
    "text": "- Full network simulation speed",
    "file": "docs\\benchmarks.md",
    "line": 81
  },
  {
    "area": "performance",
    "text": "### 2. Memory Footprint",
    "file": "docs\\benchmarks.md",
    "line": 83
  },
  {
    "area": "performance",
    "text": "Tracks memory usage across different scales:",
    "file": "docs\\benchmarks.md",
    "line": 84
  },
  {
    "area": "performance",
    "text": "- Per-neuron memory overhead",
    "file": "docs\\benchmarks.md",
    "line": 85
  },
  {
    "area": "performance",
    "text": "### 3. Convergence Speed",
    "file": "docs\\benchmarks.md",
    "line": 89
  },
  {
    "area": "performance",
    "text": "Evaluates learning efficiency on standard tasks:",
    "file": "docs\\benchmarks.md",
    "line": 90
  },
  {
    "area": "neuromodulation",
    "text": "- Homeostatic adaptation speed",
    "file": "docs\\benchmarks.md",
    "line": 93
  },
  {
    "area": "simulation_modes",
    "text": "- Simulation stepping with various configurations",
    "file": "docs\\benchmarks.md",
    "line": 106
  },
  {
    "area": "performance",
    "text": "| Throughput (1K network) | 25K neurons/sec | 50K neurons/sec | In Progress |",
    "file": "docs\\benchmarks.md",
    "line": 113
  },
  {
    "area": "performance",
    "text": "| Memory (1K network) | 15.2 MB | < 10 MB | Optimizing |",
    "file": "docs\\benchmarks.md",
    "line": 114
  },
  {
    "area": "performance",
    "text": "| Real-time Factor | 0.5x | > 1.0x | In Progress |",
    "file": "docs\\benchmarks.md",
    "line": 116
  },
  {
    "area": "api_docs",
    "text": "- Comprehensive documentation structure",
    "file": "docs\\CHANGELOG.md",
    "line": 11
  },
  {
    "area": "api_docs",
    "text": "- API reference documentation",
    "file": "docs\\CHANGELOG.md",
    "line": 12
  },
  {
    "area": "api_docs",
    "text": "- Tutorial guide for beginners",
    "file": "docs\\CHANGELOG.md",
    "line": 13
  },
  {
    "area": "edge_features",
    "text": "- Jetson Nano deployment optimization",
    "file": "docs\\CHANGELOG.md",
    "line": 14
  },
  {
    "area": "visualization_monitoring",
    "text": "- Performance monitoring and metrics",
    "file": "docs\\CHANGELOG.md",
    "line": 15
  },
  {
    "area": "edge_features",
    "text": "- Edge computing capabilities",
    "file": "docs\\CHANGELOG.md",
    "line": 16
  },
  {
    "area": "api_docs",
    "text": "- Moved documentation to `docs/` directory",
    "file": "docs\\CHANGELOG.md",
    "line": 20
  },
  {
    "area": "performance",
    "text": "- Memory optimization for large networks",
    "file": "docs\\CHANGELOG.md",
    "line": 26
  },
  {
    "area": "edge_features",
    "text": "- Jetson compatibility issues",
    "file": "docs\\CHANGELOG.md",
    "line": 28
  },
  {
    "area": "neuron_models",
    "text": "- Biological neuron models (AdEx, HH, LIF)",
    "file": "docs\\CHANGELOG.md",
    "line": 35
  },
  {
    "area": "plasticity",
    "text": "- Synaptic plasticity (STDP, STP, RSTDP)",
    "file": "docs\\CHANGELOG.md",
    "line": 36
  },
  {
    "area": "neuromodulation",
    "text": "- Neuromodulatory systems (Dopamine, Serotonin, Acetylcholine, Norepinephrine)",
    "file": "docs\\CHANGELOG.md",
    "line": 37
  },
  {
    "area": "simulation_modes",
    "text": "- Network architecture and simulation engine",
    "file": "docs\\CHANGELOG.md",
    "line": 39
  },
  {
    "area": "api_docs",
    "text": "- High-level API for easy network creation",
    "file": "docs\\CHANGELOG.md",
    "line": 40
  },
  {
    "area": "simulation_modes",
    "text": "- Event-driven simulation capabilities",
    "file": "docs\\CHANGELOG.md",
    "line": 42
  },
  {
    "area": "neuromodulation",
    "text": "- Homeostatic regulation mechanisms",
    "file": "docs\\CHANGELOG.md",
    "line": 43
  },
  {
    "area": "neuromodulation",
    "text": "- Reward-based learning algorithms",
    "file": "docs\\CHANGELOG.md",
    "line": 45
  },
  {
    "area": "edge_features",
    "text": "- Jetson Nano optimization framework",
    "file": "docs\\CHANGELOG.md",
    "line": 47
  },
  {
    "area": "visualization_monitoring",
    "text": "- Performance monitoring and metrics",
    "file": "docs\\CHANGELOG.md",
    "line": 48
  },
  {
    "area": "neuron_models",
    "text": "- **Neuron Models**: Adaptive Exponential Integrate-and-Fire, Hodgkin-Huxley, Leaky Integrate-and-Fire",
    "file": "docs\\CHANGELOG.md",
    "line": 53
  },
  {
    "area": "plasticity",
    "text": "- **Synapse Models**: STDP, Short-term plasticity, Reward-modulated STDP, Neuromodulatory synapses",
    "file": "docs\\CHANGELOG.md",
    "line": 54
  },
  {
    "area": "sensory_encoding",
    "text": "- **Sensory Encoding**: Retinal, cochlear, and somatosensory processing",
    "file": "docs\\CHANGELOG.md",
    "line": 56
  },
  {
    "area": "neuromodulation",
    "text": "- **Neuromodulation**: Four major neuromodulatory systems with realistic dynamics",
    "file": "docs\\CHANGELOG.md",
    "line": 57
  },
  {
    "area": "plasticity",
    "text": "- **Learning Algorithms**: STDP, reward-modulated learning, adaptive learning rates",
    "file": "docs\\CHANGELOG.md",
    "line": 58
  },
  {
    "area": "edge_features",
    "text": "- **Edge Computing**: Jetson Nano optimization with performance monitoring",
    "file": "docs\\CHANGELOG.md",
    "line": 59
  },
  {
    "area": "simulation_modes",
    "text": "- **Simulation Engine**: Event-driven and time-driven simulation modes",
    "file": "docs\\CHANGELOG.md",
    "line": 60
  },
  {
    "area": "api_docs",
    "text": "- **API Design**: High-level interface for rapid prototyping and development",
    "file": "docs\\CHANGELOG.md",
    "line": 61
  },
  {
    "area": "neuromodulation",
    "text": "- Network stability: Homeostatic regulation",
    "file": "docs\\CHANGELOG.md",
    "line": 66
  },
  {
    "area": "neuromodulation",
    "text": "- Neuromodulatory dynamics: Realistic neurotransmitter effects",
    "file": "docs\\CHANGELOG.md",
    "line": 67
  },
  {
    "area": "performance",
    "text": "- Memory usage: 1KB per neuron, 100B per synapse",
    "file": "docs\\CHANGELOG.md",
    "line": 71
  },
  {
    "area": "simulation_modes",
    "text": "- Simulation speed: 1000x real-time (desktop)",
    "file": "docs\\CHANGELOG.md",
    "line": 72
  },
  {
    "area": "performance",
    "text": "- Energy efficiency: 90% reduction vs traditional ANNs",
    "file": "docs\\CHANGELOG.md",
    "line": 73
  },
  {
    "area": "performance",
    "text": "- Scalability: 100-10,000 neurons, 1-20% connectivity",
    "file": "docs\\CHANGELOG.md",
    "line": 74
  },
  {
    "area": "edge_features",
    "text": "- Jetson optimization: 50-90% resource reduction",
    "file": "docs\\CHANGELOG.md",
    "line": 75
  },
  {
    "area": "api_docs",
    "text": "### Documentation",
    "file": "docs\\CHANGELOG.md",
    "line": 77
  },
  {
    "area": "api_docs",
    "text": "- API reference with examples",
    "file": "docs\\CHANGELOG.md",
    "line": 79
  },
  {
    "area": "api_docs",
    "text": "- Tutorial guide for beginners",
    "file": "docs\\CHANGELOG.md",
    "line": 80
  },
  {
    "area": "edge_features",
    "text": "- Jetson deployment guide",
    "file": "docs\\CHANGELOG.md",
    "line": 81
  },
  {
    "area": "edge_features",
    "text": "- Jetson compatibility tests",
    "file": "docs\\CHANGELOG.md",
    "line": 89
  },
  {
    "area": "edge_features",
    "text": "- Memory and resource usage tests",
    "file": "docs\\CHANGELOG.md",
    "line": 90
  },
  {
    "area": "edge_features",
    "text": "- Jetson deployment demo",
    "file": "docs\\CHANGELOG.md",
    "line": 97
  },
  {
    "area": "visualization_monitoring",
    "text": "- Performance monitoring examples",
    "file": "docs\\CHANGELOG.md",
    "line": 98
  },
  {
    "area": "neuron_models",
    "text": "- [x] Biological neuron models",
    "file": "docs\\CHANGELOG.md",
    "line": 103
  },
  {
    "area": "plasticity",
    "text": "- [x] Synaptic plasticity mechanisms",
    "file": "docs\\CHANGELOG.md",
    "line": 104
  },
  {
    "area": "simulation_modes",
    "text": "- [x] Basic simulation engine",
    "file": "docs\\CHANGELOG.md",
    "line": 106
  },
  {
    "area": "plasticity",
    "text": "- [x] STDP learning implementation",
    "file": "docs\\CHANGELOG.md",
    "line": 109
  },
  {
    "area": "neuromodulation",
    "text": "- [x] Neuromodulatory systems",
    "file": "docs\\CHANGELOG.md",
    "line": 110
  },
  {
    "area": "neuromodulation",
    "text": "- [x] Reward-based learning",
    "file": "docs\\CHANGELOG.md",
    "line": 111
  },
  {
    "area": "sensory_encoding",
    "text": "- [x] Visual encoding (retinal)",
    "file": "docs\\CHANGELOG.md",
    "line": 115
  },
  {
    "area": "sensory_encoding",
    "text": "- [x] Auditory encoding (cochlear)",
    "file": "docs\\CHANGELOG.md",
    "line": 116
  },
  {
    "area": "sensory_encoding",
    "text": "- [x] Tactile encoding (somatosensory)",
    "file": "docs\\CHANGELOG.md",
    "line": 117
  },
  {
    "area": "api_docs",
    "text": "- [x] High-level API",
    "file": "docs\\CHANGELOG.md",
    "line": 121
  },
  {
    "area": "simulation_modes",
    "text": "- [x] Event-driven simulation",
    "file": "docs\\CHANGELOG.md",
    "line": 123
  },
  {
    "area": "edge_features",
    "text": "### Phase 5: Edge Deployment \u2705",
    "file": "docs\\CHANGELOG.md",
    "line": 126
  },
  {
    "area": "edge_features",
    "text": "- [x] Jetson Nano optimization",
    "file": "docs\\CHANGELOG.md",
    "line": 127
  },
  {
    "area": "edge_features",
    "text": "- [x] Resource-constrained operation",
    "file": "docs\\CHANGELOG.md",
    "line": 128
  },
  {
    "area": "visualization_monitoring",
    "text": "- [x] Performance monitoring",
    "file": "docs\\CHANGELOG.md",
    "line": 129
  },
  {
    "area": "edge_features",
    "text": "- [x] Deployment automation",
    "file": "docs\\CHANGELOG.md",
    "line": 130
  },
  {
    "area": "api_docs",
    "text": "### Phase 6: Documentation and Testing \u2705",
    "file": "docs\\CHANGELOG.md",
    "line": 132
  },
  {
    "area": "api_docs",
    "text": "- [x] Comprehensive documentation",
    "file": "docs\\CHANGELOG.md",
    "line": 133
  },
  {
    "area": "api_docs",
    "text": "- [x] API reference",
    "file": "docs\\CHANGELOG.md",
    "line": 134
  },
  {
    "area": "api_docs",
    "text": "- [x] Tutorial guide",
    "file": "docs\\CHANGELOG.md",
    "line": 135
  },
  {
    "area": "plasticity",
    "text": "- [ ] Structural plasticity",
    "file": "docs\\CHANGELOG.md",
    "line": 142
  },
  {
    "area": "plasticity",
    "text": "- [ ] Meta-plasticity mechanisms",
    "file": "docs\\CHANGELOG.md",
    "line": 143
  },
  {
    "area": "edge_features",
    "text": "- [ ] Edge AI applications",
    "file": "docs\\CHANGELOG.md",
    "line": 156
  },
  {
    "area": "edge_features",
    "text": "- **Hardware Optimization**: Edge computing specialists",
    "file": "docs\\CHANGELOG.md",
    "line": 168
  },
  {
    "area": "api_docs",
    "text": "- **Documentation**: Technical writing team",
    "file": "docs\\CHANGELOG.md",
    "line": 169
  },
  {
    "area": "edge_features",
    "text": "- NVIDIA Jetson platform",
    "file": "docs\\CHANGELOG.md",
    "line": 176
  },
  {
    "area": "plasticity",
    "text": "# Learning and Plasticity Module Documentation",
    "file": "docs\\learning_plasticity.md",
    "line": 1
  },
  {
    "area": "plasticity",
    "text": "The learning and plasticity module provides a comprehensive framework for implementing synaptic plasticity mechanisms in spiking neural networks. It supports various biologically-inspired learning rules and allows for custom user-defined plasticity mechanisms.",
    "file": "docs\\learning_plasticity.md",
    "line": 5
  },
  {
    "area": "plasticity",
    "text": "### Built-in Plasticity Rules",
    "file": "docs\\learning_plasticity.md",
    "line": 9
  },
  {
    "area": "plasticity",
    "text": "1. **STDP (Spike-Timing-Dependent Plasticity)**",
    "file": "docs\\learning_plasticity.md",
    "line": 11
  },
  {
    "area": "plasticity",
    "text": "- Classical STDP with exponential windows",
    "file": "docs\\learning_plasticity.md",
    "line": 12
  },
  {
    "area": "plasticity",
    "text": "2. **Hebbian Learning**",
    "file": "docs\\learning_plasticity.md",
    "line": 16
  },
  {
    "area": "plasticity",
    "text": "4. **Reward-Modulated STDP**",
    "file": "docs\\learning_plasticity.md",
    "line": 26
  },
  {
    "area": "plasticity",
    "text": "- Combines timing-based and reward-based plasticity",
    "file": "docs\\learning_plasticity.md",
    "line": 27
  },
  {
    "area": "neuromodulation",
    "text": "- Dopamine-like neuromodulation",
    "file": "docs\\learning_plasticity.md",
    "line": 29
  },
  {
    "area": "plasticity",
    "text": "5. **Triplet STDP**",
    "file": "docs\\learning_plasticity.md",
    "line": 31
  },
  {
    "area": "plasticity",
    "text": "6. **Homeostatic Plasticity**",
    "file": "docs\\learning_plasticity.md",
    "line": 36
  },
  {
    "area": "plasticity",
    "text": "### Custom Plasticity Rules",
    "file": "docs\\learning_plasticity.md",
    "line": 41
  },
  {
    "area": "plasticity",
    "text": "Users can define their own plasticity rules by:",
    "file": "docs\\learning_plasticity.md",
    "line": 43
  },
  {
    "area": "plasticity",
    "text": "- Extending the `PlasticityRule` base class",
    "file": "docs\\learning_plasticity.md",
    "line": 45
  },
  {
    "area": "plasticity",
    "text": "- Using the `CustomPlasticityRule` wrapper",
    "file": "docs\\learning_plasticity.md",
    "line": 46
  },
  {
    "area": "plasticity",
    "text": "from core.learning import PlasticityManager, PlasticityConfig",
    "file": "docs\\learning_plasticity.md",
    "line": 53
  },
  {
    "area": "plasticity",
    "text": "config = PlasticityConfig(",
    "file": "docs\\learning_plasticity.md",
    "line": 56
  },
  {
    "area": "plasticity",
    "text": "manager = PlasticityManager(config)",
    "file": "docs\\learning_plasticity.md",
    "line": 65
  },
  {
    "area": "plasticity",
    "text": "manager.activate_rule('stdp')",
    "file": "docs\\learning_plasticity.md",
    "line": 68
  },
  {
    "area": "neuromodulation",
    "text": "manager.activate_rule('homeostatic')",
    "file": "docs\\learning_plasticity.md",
    "line": 69
  },
  {
    "area": "plasticity",
    "text": "# STDP parameters",
    "file": "docs\\learning_plasticity.md",
    "line": 90
  },
  {
    "area": "plasticity",
    "text": "# Hebbian parameters",
    "file": "docs\\learning_plasticity.md",
    "line": 96
  },
  {
    "area": "plasticity",
    "text": "hebbian_threshold: 0.5",
    "file": "docs\\learning_plasticity.md",
    "line": 97
  },
  {
    "area": "plasticity",
    "text": "hebbian_decay: 0.99",
    "file": "docs\\learning_plasticity.md",
    "line": 98
  },
  {
    "area": "neuromodulation",
    "text": "# Reward modulation",
    "file": "docs\\learning_plasticity.md",
    "line": 100
  },
  {
    "area": "neuromodulation",
    "text": "reward_sensitivity: 1.0",
    "file": "docs\\learning_plasticity.md",
    "line": 101
  },
  {
    "area": "neuromodulation",
    "text": "dopamine_time_constant: 200.0",
    "file": "docs\\learning_plasticity.md",
    "line": 102
  },
  {
    "area": "plasticity",
    "text": "manager = PlasticityManager()",
    "file": "docs\\learning_plasticity.md",
    "line": 107
  },
  {
    "area": "plasticity",
    "text": "\"hebbian_threshold\": 0.5",
    "file": "docs\\learning_plasticity.md",
    "line": 120
  },
  {
    "area": "plasticity",
    "text": "### Custom Plasticity Rule",
    "file": "docs\\learning_plasticity.md",
    "line": 129
  },
  {
    "area": "plasticity",
    "text": "Custom plasticity rule example.",
    "file": "docs\\learning_plasticity.md",
    "line": 134
  },
  {
    "area": "plasticity",
    "text": "config: PlasticityConfig instance",
    "file": "docs\\learning_plasticity.md",
    "line": 141
  },
  {
    "area": "neuromodulation",
    "text": "### Reward-Modulated Learning",
    "file": "docs\\learning_plasticity.md",
    "line": 165
  },
  {
    "area": "plasticity",
    "text": "# Create manager with reward-modulated STDP",
    "file": "docs\\learning_plasticity.md",
    "line": 168
  },
  {
    "area": "plasticity",
    "text": "manager = PlasticityManager(config)",
    "file": "docs\\learning_plasticity.md",
    "line": 169
  },
  {
    "area": "plasticity",
    "text": "manager.activate_rule('rstdp')",
    "file": "docs\\learning_plasticity.md",
    "line": 170
  },
  {
    "area": "simulation_modes",
    "text": "# During simulation",
    "file": "docs\\learning_plasticity.md",
    "line": 172
  },
  {
    "area": "neuromodulation",
    "text": "# Compute reward based on performance",
    "file": "docs\\learning_plasticity.md",
    "line": 174
  },
  {
    "area": "neuromodulation",
    "text": "reward = compute_reward(performance)",
    "file": "docs\\learning_plasticity.md",
    "line": 175
  },
  {
    "area": "neuromodulation",
    "text": "# Set reward signal",
    "file": "docs\\learning_plasticity.md",
    "line": 177
  },
  {
    "area": "neuromodulation",
    "text": "manager.set_reward(reward)",
    "file": "docs\\learning_plasticity.md",
    "line": 178
  },
  {
    "area": "neuromodulation",
    "text": "# Update weights with reward modulation",
    "file": "docs\\learning_plasticity.md",
    "line": 180
  },
  {
    "area": "plasticity",
    "text": "from core.synapses import STDP_Synapse",
    "file": "docs\\learning_plasticity.md",
    "line": 189
  },
  {
    "area": "plasticity",
    "text": "# Create synapse with integrated plasticity",
    "file": "docs\\learning_plasticity.md",
    "line": 191
  },
  {
    "area": "plasticity",
    "text": "synapse = STDP_Synapse(",
    "file": "docs\\learning_plasticity.md",
    "line": 192
  },
  {
    "area": "plasticity",
    "text": "tau_stdp=20.0,",
    "file": "docs\\learning_plasticity.md",
    "line": 196
  },
  {
    "area": "plasticity",
    "text": "# The synapse automatically has a PlasticityManager",
    "file": "docs\\learning_plasticity.md",
    "line": 201
  },
  {
    "area": "plasticity",
    "text": "# configured for STDP learning",
    "file": "docs\\learning_plasticity.md",
    "line": 202
  },
  {
    "area": "plasticity",
    "text": "Multiple plasticity rules can be active simultaneously:",
    "file": "docs\\learning_plasticity.md",
    "line": 209
  },
  {
    "area": "plasticity",
    "text": "manager.activate_rule('stdp')",
    "file": "docs\\learning_plasticity.md",
    "line": 212
  },
  {
    "area": "neuromodulation",
    "text": "manager.activate_rule('homeostatic')",
    "file": "docs\\learning_plasticity.md",
    "line": 213
  },
  {
    "area": "plasticity",
    "text": "# Update only with STDP",
    "file": "docs\\learning_plasticity.md",
    "line": 225
  },
  {
    "area": "plasticity",
    "text": "rule_name='stdp'",
    "file": "docs\\learning_plasticity.md",
    "line": 228
  },
  {
    "area": "visualization_monitoring",
    "text": "### Statistics and Monitoring",
    "file": "docs\\learning_plasticity.md",
    "line": 232
  },
  {
    "area": "plasticity",
    "text": "Get statistics about plasticity:",
    "file": "docs\\learning_plasticity.md",
    "line": 234
  },
  {
    "area": "api_docs",
    "text": "## Parameters Reference",
    "file": "docs\\learning_plasticity.md",
    "line": 242
  },
  {
    "area": "plasticity",
    "text": "- `enabled`: Whether plasticity is enabled",
    "file": "docs\\learning_plasticity.md",
    "line": 248
  },
  {
    "area": "plasticity",
    "text": "### STDP Parameters",
    "file": "docs\\learning_plasticity.md",
    "line": 250
  },
  {
    "area": "plasticity",
    "text": "### Hebbian Parameters",
    "file": "docs\\learning_plasticity.md",
    "line": 256
  },
  {
    "area": "plasticity",
    "text": "- `hebbian_threshold`: Correlation threshold for potentiation",
    "file": "docs\\learning_plasticity.md",
    "line": 257
  },
  {
    "area": "plasticity",
    "text": "- `hebbian_decay`: Weight decay factor",
    "file": "docs\\learning_plasticity.md",
    "line": 258
  },
  {
    "area": "neuromodulation",
    "text": "### Reward Modulation Parameters",
    "file": "docs\\learning_plasticity.md",
    "line": 264
  },
  {
    "area": "neuromodulation",
    "text": "- `reward_decay`: Eligibility trace decay rate",
    "file": "docs\\learning_plasticity.md",
    "line": 265
  },
  {
    "area": "neuromodulation",
    "text": "- `reward_sensitivity`: Sensitivity to reward signals",
    "file": "docs\\learning_plasticity.md",
    "line": 266
  },
  {
    "area": "neuromodulation",
    "text": "- `dopamine_time_constant`: Dopamine trace decay time constant",
    "file": "docs\\learning_plasticity.md",
    "line": 267
  },
  {
    "area": "neuromodulation",
    "text": "### Homeostatic Parameters",
    "file": "docs\\learning_plasticity.md",
    "line": 269
  },
  {
    "area": "neuromodulation",
    "text": "- `homeostatic_time_constant`: Adaptation time constant",
    "file": "docs\\learning_plasticity.md",
    "line": 271
  },
  {
    "area": "plasticity",
    "text": "- STDP learning with spike patterns",
    "file": "docs\\learning_plasticity.md",
    "line": 282
  },
  {
    "area": "plasticity",
    "text": "- Hebbian learning with correlated activity",
    "file": "docs\\learning_plasticity.md",
    "line": 283
  },
  {
    "area": "neuromodulation",
    "text": "- Reward-modulated learning",
    "file": "docs\\learning_plasticity.md",
    "line": 284
  },
  {
    "area": "plasticity",
    "text": "- Custom plasticity rules",
    "file": "docs\\learning_plasticity.md",
    "line": 286
  },
  {
    "area": "plasticity",
    "text": "3. **Combine complementary rules**: Use STDP for fast learning with homeostatic plasticity for stability",
    "file": "docs\\learning_plasticity.md",
    "line": 296
  },
  {
    "area": "plasticity",
    "text": "6. **Test custom rules thoroughly**: Validate custom plasticity rules on simple networks first",
    "file": "docs\\learning_plasticity.md",
    "line": 302
  },
  {
    "area": "plasticity",
    "text": "- Add homeostatic plasticity",
    "file": "docs\\learning_plasticity.md",
    "line": 309
  },
  {
    "area": "plasticity",
    "text": "- Use BCM or homeostatic plasticity for stability",
    "file": "docs\\learning_plasticity.md",
    "line": 314
  },
  {
    "area": "plasticity",
    "text": "- Verify plasticity is enabled",
    "file": "docs\\learning_plasticity.md",
    "line": 317
  },
  {
    "area": "api_docs",
    "text": "## References",
    "file": "docs\\learning_plasticity.md",
    "line": 321
  },
  {
    "area": "plasticity",
    "text": "- Pfister, J. P., & Gerstner, W. (2006). Triplets of spikes in a model of spike timing-dependent plasticity. Journal of Neuroscience, 26(38), 9673-9682.",
    "file": "docs\\learning_plasticity.md",
    "line": 327
  },
  {
    "area": "performance",
    "text": "# Memory Subsystem Documentation",
    "file": "docs\\memory_subsystem.md",
    "line": 1
  },
  {
    "area": "performance",
    "text": "The memory subsystem provides neuromorphic implementations of short-term (working) and long-term memory abstractions backed by recurrent connections and weight consolidation mechanisms. This system mimics biological memory processes through:",
    "file": "docs\\memory_subsystem.md",
    "line": 5
  },
  {
    "area": "performance",
    "text": "- **Short-term Memory (STM)**: Sustained neural activity through recurrent connections",
    "file": "docs\\memory_subsystem.md",
    "line": 7
  },
  {
    "area": "performance",
    "text": "- **Long-term Memory (LTM)**: Weight consolidation and structural changes",
    "file": "docs\\memory_subsystem.md",
    "line": 8
  },
  {
    "area": "performance",
    "text": "- **Integrated Memory System**: Coordinated STM-LTM interactions with automatic consolidation",
    "file": "docs\\memory_subsystem.md",
    "line": 9
  },
  {
    "area": "performance",
    "text": "### 1. Memory Types",
    "file": "docs\\memory_subsystem.md",
    "line": 13
  },
  {
    "area": "performance",
    "text": "#### Short-Term Memory (ShortTermMemory)",
    "file": "docs\\memory_subsystem.md",
    "line": 15
  },
  {
    "area": "performance",
    "text": "- Content-addressable memory (partial cue retrieval)",
    "file": "docs\\memory_subsystem.md",
    "line": 22
  },
  {
    "area": "performance",
    "text": "#### Long-Term Memory (LongTermMemory)",
    "file": "docs\\memory_subsystem.md",
    "line": 24
  },
  {
    "area": "plasticity",
    "text": "- Hebbian-like encoding",
    "file": "docs\\memory_subsystem.md",
    "line": 29
  },
  {
    "area": "performance",
    "text": "#### `RecurrentMemoryNetwork`",
    "file": "docs\\memory_subsystem.md",
    "line": 35
  },
  {
    "area": "performance",
    "text": "network = RecurrentMemoryNetwork(",
    "file": "docs\\memory_subsystem.md",
    "line": 38
  },
  {
    "area": "performance",
    "text": "#### `IntegratedMemorySystem`",
    "file": "docs\\memory_subsystem.md",
    "line": 57
  },
  {
    "area": "performance",
    "text": "memory = IntegratedMemorySystem(",
    "file": "docs\\memory_subsystem.md",
    "line": 60
  },
  {
    "area": "performance",
    "text": "### 1. Working Memory",
    "file": "docs\\memory_subsystem.md",
    "line": 69
  },
  {
    "area": "performance",
    "text": "### 2. Memory Consolidation",
    "file": "docs\\memory_subsystem.md",
    "line": 74
  },
  {
    "area": "performance",
    "text": "- **Partial Cue Retrieval**: Content-addressable memory",
    "file": "docs\\memory_subsystem.md",
    "line": 82
  },
  {
    "area": "performance",
    "text": "### Basic Memory Operations",
    "file": "docs\\memory_subsystem.md",
    "line": 86
  },
  {
    "area": "performance",
    "text": "from core.memory import IntegratedMemorySystem",
    "file": "docs\\memory_subsystem.md",
    "line": 89
  },
  {
    "area": "performance",
    "text": "# Create memory system",
    "file": "docs\\memory_subsystem.md",
    "line": 92
  },
  {
    "area": "performance",
    "text": "memory = IntegratedMemorySystem()",
    "file": "docs\\memory_subsystem.md",
    "line": 93
  },
  {
    "area": "performance",
    "text": "success = memory.store(pattern, duration=\"short\")",
    "file": "docs\\memory_subsystem.md",
    "line": 97
  },
  {
    "area": "performance",
    "text": "retrieved = memory.retrieve(cue)",
    "file": "docs\\memory_subsystem.md",
    "line": 101
  },
  {
    "area": "performance",
    "text": "# Consolidate to long-term memory",
    "file": "docs\\memory_subsystem.md",
    "line": 103
  },
  {
    "area": "performance",
    "text": "memory.consolidate_stm_to_ltm()",
    "file": "docs\\memory_subsystem.md",
    "line": 104
  },
  {
    "area": "performance",
    "text": "memory.store(pattern)",
    "file": "docs\\memory_subsystem.md",
    "line": 118
  },
  {
    "area": "performance",
    "text": "completed = memory.retrieve(corrupted)",
    "file": "docs\\memory_subsystem.md",
    "line": 122
  },
  {
    "area": "performance",
    "text": "from examples.sequence_learning_demo import TemporalMemoryNetwork",
    "file": "docs\\memory_subsystem.md",
    "line": 131
  },
  {
    "area": "performance",
    "text": "temporal_net = TemporalMemoryNetwork(",
    "file": "docs\\memory_subsystem.md",
    "line": 134
  },
  {
    "area": "performance",
    "text": "- Working memory capacity limits",
    "file": "docs\\memory_subsystem.md",
    "line": 157
  },
  {
    "area": "performance",
    "text": "- Memory consolidation dynamics",
    "file": "docs\\memory_subsystem.md",
    "line": 160
  },
  {
    "area": "performance",
    "text": "### Short-Term Memory",
    "file": "docs\\memory_subsystem.md",
    "line": 184
  },
  {
    "area": "performance",
    "text": "### Long-Term Memory",
    "file": "docs\\memory_subsystem.md",
    "line": 190
  },
  {
    "area": "performance",
    "text": "### Memory Transitions",
    "file": "docs\\memory_subsystem.md",
    "line": 196
  },
  {
    "area": "plasticity",
    "text": "- **Learning Rate**: \u03b1 = 0.01 for STDP",
    "file": "docs\\memory_subsystem.md",
    "line": 211
  },
  {
    "area": "neuron_models",
    "text": "- **Neurons**: Adaptive Exponential Integrate-and-Fire (AdEx)",
    "file": "docs\\memory_subsystem.md",
    "line": 216
  },
  {
    "area": "plasticity",
    "text": "- **Synapses**: STDP with asymmetric learning windows",
    "file": "docs\\memory_subsystem.md",
    "line": 217
  },
  {
    "area": "plasticity",
    "text": "- **Plasticity**: Hebbian and spike-timing dependent",
    "file": "docs\\memory_subsystem.md",
    "line": 219
  },
  {
    "area": "performance",
    "text": "1. **Episodic Memory**: Sequence of events with temporal context",
    "file": "docs\\memory_subsystem.md",
    "line": 223
  },
  {
    "area": "performance",
    "text": "2. **Semantic Memory**: Hierarchical concept organization",
    "file": "docs\\memory_subsystem.md",
    "line": 224
  },
  {
    "area": "performance",
    "text": "3. **Memory Replay**: Offline consolidation during rest",
    "file": "docs\\memory_subsystem.md",
    "line": 225
  },
  {
    "area": "performance",
    "text": "6. **Multi-modal Integration**: Cross-modal memory binding",
    "file": "docs\\memory_subsystem.md",
    "line": 228
  },
  {
    "area": "api_docs",
    "text": "## References",
    "file": "docs\\memory_subsystem.md",
    "line": 230
  },
  {
    "area": "performance",
    "text": "3. O'Reilly, R. C., & Norman, K. A. (2002). \"Hippocampal and neocortical contributions to memory\"",
    "file": "docs\\memory_subsystem.md",
    "line": 234
  },
  {
    "area": "performance",
    "text": "Run the demonstration scripts to test the memory subsystem:",
    "file": "docs\\memory_subsystem.md",
    "line": 240
  },
  {
    "area": "performance",
    "text": "- Visualization of memory dynamics",
    "file": "docs\\memory_subsystem.md",
    "line": 252
  },
  {
    "area": "neuron_models",
    "text": "- **Adaptive Exponential Integrate-and-Fire (AdEx) Model**: Combines biological realism with computational efficiency",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 12
  },
  {
    "area": "neuron_models",
    "text": "- **Ion Channel Dynamics**: Simplified Hodgkin-Huxley with Na+, K+, and leak channels",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 18
  },
  {
    "area": "plasticity",
    "text": "### 1.2 Synaptic Plasticity",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 27
  },
  {
    "area": "plasticity",
    "text": "**Short-term Plasticity (STP)**:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 29
  },
  {
    "area": "plasticity",
    "text": "**Spike-Timing-Dependent Plasticity (STDP)**:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 34
  },
  {
    "area": "plasticity",
    "text": "**Long-term Plasticity**:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 41
  },
  {
    "area": "plasticity",
    "text": "- **Meta-plasticity**: BCM rule for sliding threshold",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 43
  },
  {
    "area": "neuromodulation",
    "text": "- **Synaptic Scaling**: Homeostatic regulation of total synaptic strength",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 44
  },
  {
    "area": "performance",
    "text": "- **Recurrent**: Working memory and temporal integration",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 58
  },
  {
    "area": "simulation_modes",
    "text": "**Event-Driven Processing**:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 68
  },
  {
    "area": "neuromodulation",
    "text": "**Neuromodulatory Systems**:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 75
  },
  {
    "area": "neuromodulation",
    "text": "- **Dopamine**: Reward prediction error, reinforcement learning",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 76
  },
  {
    "area": "neuromodulation",
    "text": "- **Serotonin**: Mood regulation, behavioral state",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 77
  },
  {
    "area": "neuromodulation",
    "text": "- **Acetylcholine**: Attention, learning rate modulation",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 78
  },
  {
    "area": "neuromodulation",
    "text": "- **Norepinephrine**: Arousal, vigilance",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 79
  },
  {
    "area": "neuromodulation",
    "text": "**Homeostatic Mechanisms**:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 81
  },
  {
    "area": "plasticity",
    "text": "- **Intrinsic Plasticity**: Adjustment of neuron excitability",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 83
  },
  {
    "area": "plasticity",
    "text": "- **Structural Plasticity**: Dynamic synapse formation/elimination",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 84
  },
  {
    "area": "neuron_models",
    "text": "### 2.1 Neuron Model Implementation",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 88
  },
  {
    "area": "plasticity",
    "text": "class STDP_Synapse:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 135
  },
  {
    "area": "plasticity",
    "text": "def __init__(self, weight=1.0, tau_stdp=20.0, A_plus=0.01, A_minus=0.01):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 136
  },
  {
    "area": "plasticity",
    "text": "self.tau_stdp = tau_stdp",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 138
  },
  {
    "area": "plasticity",
    "text": "# STDP: Pre-before-post strengthens synapse",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 145
  },
  {
    "area": "plasticity",
    "text": "if t - self.last_post_spike < self.tau_stdp:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 146
  },
  {
    "area": "plasticity",
    "text": "delta_w = self.A_plus * np.exp(-(t - self.last_post_spike) / self.tau_stdp)",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 147
  },
  {
    "area": "plasticity",
    "text": "# STDP: Post-before-pre weakens synapse",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 152
  },
  {
    "area": "plasticity",
    "text": "if t - self.last_pre_spike < self.tau_stdp:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 153
  },
  {
    "area": "plasticity",
    "text": "delta_w = -self.A_minus * np.exp(-(t - self.last_pre_spike) / self.tau_stdp)",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 154
  },
  {
    "area": "sensory_encoding",
    "text": "1. **Input Layer**: Sensory encoding (retina, cochlea, somatosensory)",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 164
  },
  {
    "area": "neuron_models",
    "text": "def add_layer(self, name, size, neuron_type=\"adex\"):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 185
  },
  {
    "area": "neuron_models",
    "text": "elif connection_type == \"feedforward\":",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 197
  },
  {
    "area": "neuron_models",
    "text": "elif connection_type == \"lateral\":",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 199
  },
  {
    "area": "plasticity",
    "text": "### 4.1 STDP Implementation",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 205
  },
  {
    "area": "plasticity",
    "text": "class STDP_Learning:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 208
  },
  {
    "area": "neuromodulation",
    "text": "### 4.2 Neuromodulatory Learning",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 227
  },
  {
    "area": "neuromodulation",
    "text": "class NeuromodulatoryLearning:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 230
  },
  {
    "area": "neuromodulation",
    "text": "self.dopamine_level = 0.0",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 232
  },
  {
    "area": "neuromodulation",
    "text": "self.serotonin_level = 0.0",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 233
  },
  {
    "area": "neuromodulation",
    "text": "self.acetylcholine_level = 0.0",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 234
  },
  {
    "area": "neuromodulation",
    "text": "def update_learning_rate(self, reward_prediction_error):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 236
  },
  {
    "area": "neuromodulation",
    "text": "# Dopamine modulates learning rate",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 237
  },
  {
    "area": "neuromodulation",
    "text": "self.dopamine_level = np.clip(self.dopamine_level + reward_prediction_error, 0, 1)",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 238
  },
  {
    "area": "neuromodulation",
    "text": "learning_rate_multiplier = 1.0 + 2.0 * self.dopamine_level",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 239
  },
  {
    "area": "simulation_modes",
    "text": "## 5. Data Encoding and Event-Driven Processing",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 243
  },
  {
    "area": "sensory_encoding",
    "text": "class RetinalEncoder:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 249
  },
  {
    "area": "sensory_encoding",
    "text": "class CochlearEncoder:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 271
  },
  {
    "area": "sensory_encoding",
    "text": "# Convert audio to spike trains using cochlear model",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 277
  },
  {
    "area": "sensory_encoding",
    "text": "response = self._compute_cochlear_response(audio_signal, freq)",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 280
  },
  {
    "area": "simulation_modes",
    "text": "### 5.2 Event-Driven Simulation",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 286
  },
  {
    "area": "simulation_modes",
    "text": "def run_simulation(self, duration):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 297
  },
  {
    "area": "neuron_models",
    "text": "- **Neuron Cores**: Map AdEx models to Loihi neuron cores",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 311
  },
  {
    "area": "plasticity",
    "text": "- **Synapse Arrays**: STDP implemented in synaptic plasticity engines",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 312
  },
  {
    "area": "simulation_modes",
    "text": "- **Routing**: Event-driven communication via packet-based routing",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 313
  },
  {
    "area": "plasticity",
    "text": "- **Learning**: On-chip learning engines for STDP updates",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 314
  },
  {
    "area": "neuron_models",
    "text": "- **Neuron Models**: Simplified integrate-and-fire with configurable parameters",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 317
  },
  {
    "area": "edge_features",
    "text": "- **Power Efficiency**: Sub-threshold operation for ultra-low power",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 320
  },
  {
    "area": "neuron_models",
    "text": "elif self.backend == \"nengo\":",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 336
  },
  {
    "area": "neuron_models",
    "text": "def add_neuron_group(self, n_neurons, model=\"AdEx\"):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 340
  },
  {
    "area": "neuron_models",
    "text": "elif self.backend == \"nengo\":",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 343
  },
  {
    "area": "api_docs",
    "text": "### 7.1 High-Level API",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 349
  },
  {
    "area": "api_docs",
    "text": "class NeuromorphicAPI:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 352
  },
  {
    "area": "neuron_models",
    "text": "def create_processing_layer(self, name, size, neuron_type=\"adex\"):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 362
  },
  {
    "area": "plasticity",
    "text": "\"\"\"Connect layers with specified pattern and plasticity rules\"\"\"",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 369
  },
  {
    "area": "plasticity",
    "text": "def add_learning_rule(self, connection, learning_type=\"stdp\"):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 374
  },
  {
    "area": "plasticity",
    "text": "if learning_type == \"stdp\":",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 376
  },
  {
    "area": "plasticity",
    "text": "rule = STDP_Learning()",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 377
  },
  {
    "area": "neuron_models",
    "text": "elif learning_type == \"neuromodulatory\":",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 378
  },
  {
    "area": "neuromodulation",
    "text": "rule = NeuromodulatoryLearning()",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 379
  },
  {
    "area": "simulation_modes",
    "text": "def run_simulation(self, duration, dt=0.1):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 382
  },
  {
    "area": "simulation_modes",
    "text": "\"\"\"Run simulation for specified duration\"\"\"",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 383
  },
  {
    "area": "visualization_monitoring",
    "text": "### 7.2 Visualization Tools",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 388
  },
  {
    "area": "visualization_monitoring",
    "text": "def plot_spike_raster(self, spike_data, title=\"Spike Raster\"):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 395
  },
  {
    "area": "simulation_modes",
    "text": "\"\"\"Plot spike raster from simulation data\"\"\"",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 396
  },
  {
    "area": "visualization_monitoring",
    "text": "plt.plot(spike_times, [neuron_id] * len(spike_times), 'k.', markersize=1)",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 399
  },
  {
    "area": "visualization_monitoring",
    "text": "def plot_weight_evolution(self, weight_history, title=\"Synaptic Weight Evolution\"):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 405
  },
  {
    "area": "visualization_monitoring",
    "text": "\"\"\"Plot evolution of synaptic weights over time\"\"\"",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 406
  },
  {
    "area": "visualization_monitoring",
    "text": "plt.plot(weights, label=f'Synapse {synapse_id}')",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 409
  },
  {
    "area": "simulation_modes",
    "text": "plt.xlabel('Time Step')",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 410
  },
  {
    "area": "visualization_monitoring",
    "text": "def plot_network_activity(self, activity_matrix, title=\"Network Activity\"):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 416
  },
  {
    "area": "visualization_monitoring",
    "text": "\"\"\"Plot network activity heatmap\"\"\"",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 417
  },
  {
    "area": "performance",
    "text": "**Energy Efficiency**:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 458
  },
  {
    "area": "simulation_modes",
    "text": "def calculate_energy_efficiency(spike_count, simulation_time, power_consumption):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 460
  },
  {
    "area": "performance",
    "text": "\"\"\"Calculate energy efficiency in terms of spikes per joule\"\"\"",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 461
  },
  {
    "area": "simulation_modes",
    "text": "total_energy = power_consumption * simulation_time",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 462
  },
  {
    "area": "performance",
    "text": "efficiency = spike_count / total_energy",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 463
  },
  {
    "area": "performance",
    "text": "return efficiency",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 464
  },
  {
    "area": "performance",
    "text": "**Latency and Throughput**:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 467
  },
  {
    "area": "simulation_modes",
    "text": "def measure_latency_throughput(input_spikes, output_spikes, simulation_time):",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 469
  },
  {
    "area": "performance",
    "text": "\"\"\"Measure system latency and throughput\"\"\"",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 470
  },
  {
    "area": "simulation_modes",
    "text": "throughput = len(output_spikes) / simulation_time",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 472
  },
  {
    "area": "performance",
    "text": "return {'latency': latency, 'throughput': throughput}",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 473
  },
  {
    "area": "sensory_encoding",
    "text": "self.visual_input = SensoryLayer(1024, \"retinal_encoding\")",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 484
  },
  {
    "area": "sensory_encoding",
    "text": "self.auditory_input = SensoryLayer(256, \"cochlear_encoding\")",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 485
  },
  {
    "area": "sensory_encoding",
    "text": "self.tactile_input = SensoryLayer(512, \"somatosensory_encoding\")",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 486
  },
  {
    "area": "neuron_models",
    "text": "self.sensory_integration = ProcessingLayer(512, \"adex\")",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 489
  },
  {
    "area": "neuron_models",
    "text": "self.pattern_recognition = ProcessingLayer(256, \"adex\")",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 490
  },
  {
    "area": "neuron_models",
    "text": "self.decision_making = ProcessingLayer(128, \"adex\")",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 491
  },
  {
    "area": "neuron_models",
    "text": "self.motor_planning = ProcessingLayer(64, \"adex\")",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 494
  },
  {
    "area": "neuromodulation",
    "text": "self.reward_system = RewardSystem()",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 498
  },
  {
    "area": "neuromodulation",
    "text": "self.learning_controller = NeuromodulatoryLearning()",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 499
  },
  {
    "area": "plasticity",
    "text": "connection.add_learning_rule(\"stdp\")",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 521
  },
  {
    "area": "neuromodulation",
    "text": "connection.add_learning_rule(\"neuromodulatory\")",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 522
  },
  {
    "area": "neuromodulation",
    "text": "total_reward = 0",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 531
  },
  {
    "area": "simulation_modes",
    "text": "# Run simulation",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 539
  },
  {
    "area": "simulation_modes",
    "text": "motor_output = system.run_simulation(100.0)  # 100ms trial",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 540
  },
  {
    "area": "neuromodulation",
    "text": "# Calculate reward",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 542
  },
  {
    "area": "neuromodulation",
    "text": "reward = calculate_reward(motor_output, trial['target'])",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 543
  },
  {
    "area": "neuromodulation",
    "text": "total_reward += reward",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 544
  },
  {
    "area": "neuromodulation",
    "text": "system.learning_controller.update_learning_rate(reward)",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 547
  },
  {
    "area": "neuromodulation",
    "text": "print(f\"Epoch {epoch}: Average reward = {total_reward / len(training_data)}\")",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 549
  },
  {
    "area": "performance",
    "text": "## 10. Scalability, Extensibility, and Future Directions",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 552
  },
  {
    "area": "plasticity",
    "text": "**Advanced Plasticity Mechanisms**:",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 591
  },
  {
    "area": "plasticity",
    "text": "- **Structural Plasticity**: Dynamic synapse formation/elimination",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 592
  },
  {
    "area": "plasticity",
    "text": "- **Meta-plasticity**: Higher-order learning rules",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 593
  },
  {
    "area": "plasticity",
    "text": "- **Epigenetic Regulation**: Gene expression-based plasticity",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 594
  },
  {
    "area": "performance",
    "text": "- **Working Memory**: Persistent activity patterns",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 597
  },
  {
    "area": "neuron_models",
    "text": "- Simplified neuron models may miss critical dynamics",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 606
  },
  {
    "area": "plasticity",
    "text": "- Limited synaptic plasticity mechanisms",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 607
  },
  {
    "area": "neuromodulation",
    "text": "- Incomplete neuromodulatory systems",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 608
  },
  {
    "area": "edge_features",
    "text": "- Power and thermal limitations",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 613
  },
  {
    "area": "simulation_modes",
    "text": "- Event-driven simulation complexity",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 616
  },
  {
    "area": "performance",
    "text": "- Real-time processing requirements",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 617
  },
  {
    "area": "performance",
    "text": "- Scalability bottlenecks",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 618
  },
  {
    "area": "simulation_modes",
    "text": "- Create event-driven simulation engine",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 641
  },
  {
    "area": "api_docs",
    "text": "- Develop high-level API",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 642
  },
  {
    "area": "visualization_monitoring",
    "text": "- Build visualization tools",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 643
  },
  {
    "area": "plasticity",
    "text": "- Implement STDP learning rules",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 646
  },
  {
    "area": "neuromodulation",
    "text": "- Add neuromodulatory systems",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 647
  },
  {
    "area": "neuromodulation",
    "text": "- Create reward-based learning",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 648
  },
  {
    "area": "neuromodulation",
    "text": "- Develop homeostatic mechanisms",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 649
  },
  {
    "area": "edge_features",
    "text": "- Optimize for power efficiency",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 653
  },
  {
    "area": "performance",
    "text": "- Implement real-time processing",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 654
  },
  {
    "area": "simulation_modes",
    "text": "This specification provides a comprehensive blueprint for a true neuromorphic programming system that bridges the gap between biological neuroscience and practical computing applications. The system's event-driven, temporally precise, and adaptive nature offers significant advantages over traditional artificial neural networks for real-time, energy-efficient processing of complex sensory data.",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 665
  },
  {
    "area": "edge_features",
    "text": "The modular design allows for incremental development and validation, while the emphasis on biological fidelity ensures that the system can leverage insights from neuroscience research. The integration with emerging neuromorphic hardware platforms provides a clear path to practical deployment.",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 667
  },
  {
    "area": "api_docs",
    "text": "## References",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 671
  },
  {
    "area": "neuron_models",
    "text": "1. Hodgkin, A. L., & Huxley, A. F. (1952). A quantitative description of membrane current and its application to conduction and excitation in nerve. The Journal of physiology, 117(4), 500-544.",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 673
  },
  {
    "area": "neuron_models",
    "text": "2. Brette, R., & Gerstner, W. (2005). Adaptive exponential integrate-and-fire model as an effective description of neuronal activity. Journal of neurophysiology, 94(5), 3637-3642.",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 675
  },
  {
    "area": "simulation_modes",
    "text": "3. Markram, H., et al. (2015). Reconstruction and simulation of neocortical microcircuitry. Cell, 163(2), 456-492.",
    "file": "docs\\NEUROMORPHIC_POC_SPECIFICATION.md",
    "line": 677
  },
  {
    "area": "performance",
    "text": "# Step 5: Memory Subsystems and Validation Demos - COMPLETED",
    "file": "docs\\step5_completion_summary.md",
    "line": 1
  },
  {
    "area": "performance",
    "text": "Successfully implemented short-term (working) and long-term memory abstractions backed by recurrent connections and weight consolidation mechanisms, along with demonstration notebooks for pattern completion and sequence learning tasks.",
    "file": "docs\\step5_completion_summary.md",
    "line": 4
  },
  {
    "area": "performance",
    "text": "### 1. Core Memory Module (`core/memory.py`)",
    "file": "docs\\step5_completion_summary.md",
    "line": 8
  },
  {
    "area": "performance",
    "text": "- **RecurrentMemoryNetwork**: Implements recurrent neural networks for sustained activity patterns",
    "file": "docs\\step5_completion_summary.md",
    "line": 9
  },
  {
    "area": "performance",
    "text": "- **ShortTermMemory**: Working memory with ~7 item capacity (Miller's law)",
    "file": "docs\\step5_completion_summary.md",
    "line": 11
  },
  {
    "area": "performance",
    "text": "- **LongTermMemory**: Persistent storage with weight consolidation",
    "file": "docs\\step5_completion_summary.md",
    "line": 12
  },
  {
    "area": "performance",
    "text": "- **IntegratedMemorySystem**: Combines STM and LTM with automatic consolidation",
    "file": "docs\\step5_completion_summary.md",
    "line": 13
  },
  {
    "area": "performance",
    "text": "### 2. Memory Types and Features",
    "file": "docs\\step5_completion_summary.md",
    "line": 15
  },
  {
    "area": "performance",
    "text": "#### Short-Term Memory (STM)",
    "file": "docs\\step5_completion_summary.md",
    "line": 17
  },
  {
    "area": "performance",
    "text": "- Content-addressable memory (partial cue retrieval)",
    "file": "docs\\step5_completion_summary.md",
    "line": 24
  },
  {
    "area": "performance",
    "text": "#### Long-Term Memory (LTM)",
    "file": "docs\\step5_completion_summary.md",
    "line": 26
  },
  {
    "area": "plasticity",
    "text": "- Hebbian-like encoding",
    "file": "docs\\step5_completion_summary.md",
    "line": 31
  },
  {
    "area": "performance",
    "text": "- Tests working memory capacity limits",
    "file": "docs\\step5_completion_summary.md",
    "line": 38
  },
  {
    "area": "performance",
    "text": "- Memory consolidation dynamics",
    "file": "docs\\step5_completion_summary.md",
    "line": 41
  },
  {
    "area": "visualization_monitoring",
    "text": "- Visualization of retrieval performance",
    "file": "docs\\step5_completion_summary.md",
    "line": 42
  },
  {
    "area": "performance",
    "text": "- **Prefrontal Cortex**: Sustained firing for working memory",
    "file": "docs\\step5_completion_summary.md",
    "line": 52
  },
  {
    "area": "plasticity",
    "text": "\u2705 STDP-based learning for long-term storage",
    "file": "docs\\step5_completion_summary.md",
    "line": 62
  },
  {
    "area": "performance",
    "text": "- Memory decay: Exponential for STM, protected for consolidated LTM",
    "file": "docs\\step5_completion_summary.md",
    "line": 71
  },
  {
    "area": "performance",
    "text": "\u2705 Unit tests for all memory components",
    "file": "docs\\step5_completion_summary.md",
    "line": 74
  },
  {
    "area": "performance",
    "text": "1. `core/memory.py` - Complete memory subsystem implementation",
    "file": "docs\\step5_completion_summary.md",
    "line": 83
  },
  {
    "area": "performance",
    "text": "4. `docs/memory_subsystem.md` - Comprehensive documentation",
    "file": "docs\\step5_completion_summary.md",
    "line": 86
  },
  {
    "area": "performance",
    "text": "5. `test_memory_subsystem.py` - Test suite for memory components",
    "file": "docs\\step5_completion_summary.md",
    "line": 87
  },
  {
    "area": "performance",
    "text": "1. `core/__init__.py` - Added memory module exports",
    "file": "docs\\step5_completion_summary.md",
    "line": 90
  },
  {
    "area": "performance",
    "text": "### Basic Memory Operations",
    "file": "docs\\step5_completion_summary.md",
    "line": 95
  },
  {
    "area": "performance",
    "text": "from core.memory import IntegratedMemorySystem",
    "file": "docs\\step5_completion_summary.md",
    "line": 97
  },
  {
    "area": "performance",
    "text": "# Create integrated memory system",
    "file": "docs\\step5_completion_summary.md",
    "line": 100
  },
  {
    "area": "performance",
    "text": "memory = IntegratedMemorySystem()",
    "file": "docs\\step5_completion_summary.md",
    "line": 101
  },
  {
    "area": "performance",
    "text": "memory.store(pattern, duration=\"short\")",
    "file": "docs\\step5_completion_summary.md",
    "line": 105
  },
  {
    "area": "performance",
    "text": "retrieved = memory.retrieve(cue)",
    "file": "docs\\step5_completion_summary.md",
    "line": 109
  },
  {
    "area": "performance",
    "text": "memory.consolidate_stm_to_ltm()",
    "file": "docs\\step5_completion_summary.md",
    "line": 112
  },
  {
    "area": "performance",
    "text": "1. **Episodic Memory**: Sequence of events with temporal context",
    "file": "docs\\step5_completion_summary.md",
    "line": 135
  },
  {
    "area": "performance",
    "text": "2. **Semantic Memory**: Hierarchical concept organization",
    "file": "docs\\step5_completion_summary.md",
    "line": 136
  },
  {
    "area": "performance",
    "text": "3. **Memory Replay**: Offline consolidation during rest states",
    "file": "docs\\step5_completion_summary.md",
    "line": 137
  },
  {
    "area": "performance",
    "text": "6. **Multi-modal Integration**: Cross-modal memory binding",
    "file": "docs\\step5_completion_summary.md",
    "line": 140
  },
  {
    "area": "performance",
    "text": "### Memory Capacity",
    "file": "docs\\step5_completion_summary.md",
    "line": 149
  },
  {
    "area": "performance",
    "text": "Step 5 has been successfully completed with a comprehensive memory subsystem implementation that includes:",
    "file": "docs\\step5_completion_summary.md",
    "line": 160
  },
  {
    "area": "performance",
    "text": "- Biologically-inspired short-term and long-term memory mechanisms",
    "file": "docs\\step5_completion_summary.md",
    "line": 161
  },
  {
    "area": "performance",
    "text": "The system successfully demonstrates key memory capabilities including working memory maintenance, pattern completion from partial cues, temporal sequence learning, and automatic consolidation from STM to LTM based on importance and access patterns.",
    "file": "docs\\step5_completion_summary.md",
    "line": 167
  },
  {
    "area": "api_docs",
    "text": "# Tutorial: Getting Started with Neuromorphic Programming",
    "file": "docs\\TUTORIAL.md",
    "line": 1
  },
  {
    "area": "neuron_models",
    "text": "3. [Neuron Models](#neuron-models)",
    "file": "docs\\TUTORIAL.md",
    "line": 9
  },
  {
    "area": "plasticity",
    "text": "4. [Synaptic Plasticity](#synaptic-plasticity)",
    "file": "docs\\TUTORIAL.md",
    "line": 10
  },
  {
    "area": "edge_features",
    "text": "8. [Jetson Deployment](#jetson-deployment)",
    "file": "docs\\TUTORIAL.md",
    "line": 14
  },
  {
    "area": "visualization_monitoring",
    "text": "- NumPy, SciPy, Matplotlib",
    "file": "docs\\TUTORIAL.md",
    "line": 21
  },
  {
    "area": "api_docs",
    "text": "from api.neuromorphic_api import NeuromorphicAPI",
    "file": "docs\\TUTORIAL.md",
    "line": 43
  },
  {
    "area": "api_docs",
    "text": "# Initialize the API",
    "file": "docs\\TUTORIAL.md",
    "line": 45
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\TUTORIAL.md",
    "line": 46
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\TUTORIAL.md",
    "line": 47
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"input\", 50, \"rate\")",
    "file": "docs\\TUTORIAL.md",
    "line": 50
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"hidden\", 25, \"adex\")",
    "file": "docs\\TUTORIAL.md",
    "line": 51
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"output\", 10)",
    "file": "docs\\TUTORIAL.md",
    "line": 52
  },
  {
    "area": "plasticity",
    "text": "api.connect_layers(\"input\", \"hidden\", \"feedforward\", synapse_type=\"stdp\")",
    "file": "docs\\TUTORIAL.md",
    "line": 55
  },
  {
    "area": "plasticity",
    "text": "api.connect_layers(\"hidden\", \"output\", \"feedforward\", synapse_type=\"stdp\")",
    "file": "docs\\TUTORIAL.md",
    "line": 56
  },
  {
    "area": "simulation_modes",
    "text": "# Run simulation",
    "file": "docs\\TUTORIAL.md",
    "line": 58
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(100.0)",
    "file": "docs\\TUTORIAL.md",
    "line": 59
  },
  {
    "area": "simulation_modes",
    "text": "print(f\"Simulation completed in {results['duration']} ms\")",
    "file": "docs\\TUTORIAL.md",
    "line": 62
  },
  {
    "area": "simulation_modes",
    "text": "# Run simulation with external input",
    "file": "docs\\TUTORIAL.md",
    "line": 73
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(100.0, external_inputs={\"input\": input_spikes})",
    "file": "docs\\TUTORIAL.md",
    "line": 74
  },
  {
    "area": "visualization_monitoring",
    "text": "import matplotlib.pyplot as plt",
    "file": "docs\\TUTORIAL.md",
    "line": 77
  },
  {
    "area": "visualization_monitoring",
    "text": "plt.subplot(len(results['layer_spike_times']), 1, i+1)",
    "file": "docs\\TUTORIAL.md",
    "line": 81
  },
  {
    "area": "neuron_models",
    "text": "## Neuron Models",
    "file": "docs\\TUTORIAL.md",
    "line": 93
  },
  {
    "area": "neuron_models",
    "text": "The system supports three neuron models:",
    "file": "docs\\TUTORIAL.md",
    "line": 97
  },
  {
    "area": "neuron_models",
    "text": "1. **AdEx (Adaptive Exponential Integrate-and-Fire)**: Most biologically realistic",
    "file": "docs\\TUTORIAL.md",
    "line": 99
  },
  {
    "area": "neuron_models",
    "text": "2. **HH (Hodgkin-Huxley)**: Full ion channel dynamics",
    "file": "docs\\TUTORIAL.md",
    "line": 100
  },
  {
    "area": "neuron_models",
    "text": "3. **LIF (Leaky Integrate-and-Fire)**: Simple and efficient",
    "file": "docs\\TUTORIAL.md",
    "line": 101
  },
  {
    "area": "neuron_models",
    "text": "# Create an AdEx neuron",
    "file": "docs\\TUTORIAL.md",
    "line": 108
  },
  {
    "area": "neuron_models",
    "text": "adex_neuron = AdaptiveExponentialIntegrateAndFire(",
    "file": "docs\\TUTORIAL.md",
    "line": 109
  },
  {
    "area": "neuron_models",
    "text": "# Create a LIF neuron",
    "file": "docs\\TUTORIAL.md",
    "line": 120
  },
  {
    "area": "neuron_models",
    "text": "lif_neuron = LeakyIntegrateAndFire(",
    "file": "docs\\TUTORIAL.md",
    "line": 121
  },
  {
    "area": "neuron_models",
    "text": "# AdEx neuron simulation",
    "file": "docs\\TUTORIAL.md",
    "line": 132
  },
  {
    "area": "neuron_models",
    "text": "adex_spikes = []",
    "file": "docs\\TUTORIAL.md",
    "line": 133
  },
  {
    "area": "neuron_models",
    "text": "if adex_neuron.step(dt=0.1, input_current=current):",
    "file": "docs\\TUTORIAL.md",
    "line": 136
  },
  {
    "area": "neuron_models",
    "text": "adex_spikes.append(t * 0.1)",
    "file": "docs\\TUTORIAL.md",
    "line": 137
  },
  {
    "area": "neuron_models",
    "text": "# LIF neuron simulation",
    "file": "docs\\TUTORIAL.md",
    "line": 139
  },
  {
    "area": "neuron_models",
    "text": "lif_spikes = []",
    "file": "docs\\TUTORIAL.md",
    "line": 140
  },
  {
    "area": "neuron_models",
    "text": "if lif_neuron.step(dt=0.1, input_current=current):",
    "file": "docs\\TUTORIAL.md",
    "line": 143
  },
  {
    "area": "neuron_models",
    "text": "lif_spikes.append(t * 0.1)",
    "file": "docs\\TUTORIAL.md",
    "line": 144
  },
  {
    "area": "neuron_models",
    "text": "print(f\"AdEx spikes: {len(adex_spikes)}\")",
    "file": "docs\\TUTORIAL.md",
    "line": 146
  },
  {
    "area": "neuron_models",
    "text": "print(f\"LIF spikes: {len(lif_spikes)}\")",
    "file": "docs\\TUTORIAL.md",
    "line": 147
  },
  {
    "area": "plasticity",
    "text": "## Synaptic Plasticity",
    "file": "docs\\TUTORIAL.md",
    "line": 150
  },
  {
    "area": "plasticity",
    "text": "### STDP Learning",
    "file": "docs\\TUTORIAL.md",
    "line": 152
  },
  {
    "area": "plasticity",
    "text": "Spike-Timing-Dependent Plasticity allows synapses to strengthen or weaken based on spike timing.",
    "file": "docs\\TUTORIAL.md",
    "line": 154
  },
  {
    "area": "plasticity",
    "text": "from core.synapses import STDP_Synapse, SynapseType",
    "file": "docs\\TUTORIAL.md",
    "line": 157
  },
  {
    "area": "plasticity",
    "text": "# Create STDP synapse",
    "file": "docs\\TUTORIAL.md",
    "line": 159
  },
  {
    "area": "plasticity",
    "text": "synapse = STDP_Synapse(",
    "file": "docs\\TUTORIAL.md",
    "line": 160
  },
  {
    "area": "plasticity",
    "text": "tau_stdp=20.0,",
    "file": "docs\\TUTORIAL.md",
    "line": 166
  },
  {
    "area": "plasticity",
    "text": "# Simulate STDP learning",
    "file": "docs\\TUTORIAL.md",
    "line": 171
  },
  {
    "area": "plasticity",
    "text": "### Reward-Modulated STDP",
    "file": "docs\\TUTORIAL.md",
    "line": 185
  },
  {
    "area": "neuromodulation",
    "text": "Combines timing-based learning with reward signals.",
    "file": "docs\\TUTORIAL.md",
    "line": 187
  },
  {
    "area": "plasticity",
    "text": "from core.synapses import RSTDP_Synapse",
    "file": "docs\\TUTORIAL.md",
    "line": 190
  },
  {
    "area": "plasticity",
    "text": "# Create RSTDP synapse",
    "file": "docs\\TUTORIAL.md",
    "line": 192
  },
  {
    "area": "plasticity",
    "text": "rstdp_synapse = RSTDP_Synapse(",
    "file": "docs\\TUTORIAL.md",
    "line": 193
  },
  {
    "area": "neuromodulation",
    "text": "# Set neuromodulator level and reward",
    "file": "docs\\TUTORIAL.md",
    "line": 201
  },
  {
    "area": "plasticity",
    "text": "rstdp_synapse.update_neuromodulator(level=0.5)",
    "file": "docs\\TUTORIAL.md",
    "line": 202
  },
  {
    "area": "plasticity",
    "text": "rstdp_synapse.update_reward(reward=1.0)",
    "file": "docs\\TUTORIAL.md",
    "line": 203
  },
  {
    "area": "plasticity",
    "text": "print(f\"Initial weight: {rstdp_synapse.weight}\")",
    "file": "docs\\TUTORIAL.md",
    "line": 206
  },
  {
    "area": "plasticity",
    "text": "rstdp_synapse.pre_spike(t=10.0)",
    "file": "docs\\TUTORIAL.md",
    "line": 207
  },
  {
    "area": "plasticity",
    "text": "rstdp_synapse.post_spike(t=12.0)",
    "file": "docs\\TUTORIAL.md",
    "line": 208
  },
  {
    "area": "plasticity",
    "text": "print(f\"Weight after RSTDP: {rstdp_synapse.weight}\")",
    "file": "docs\\TUTORIAL.md",
    "line": 209
  },
  {
    "area": "sensory_encoding",
    "text": "Convert images to spike trains using retinal-like processing.",
    "file": "docs\\TUTORIAL.md",
    "line": 216
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import RetinalEncoder",
    "file": "docs\\TUTORIAL.md",
    "line": 219
  },
  {
    "area": "sensory_encoding",
    "text": "# Create visual encoder",
    "file": "docs\\TUTORIAL.md",
    "line": 222
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = RetinalEncoder(resolution=(32, 32))",
    "file": "docs\\TUTORIAL.md",
    "line": 223
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(image)",
    "file": "docs\\TUTORIAL.md",
    "line": 237
  },
  {
    "area": "visualization_monitoring",
    "text": "import matplotlib.pyplot as plt",
    "file": "docs\\TUTORIAL.md",
    "line": 241
  },
  {
    "area": "visualization_monitoring",
    "text": "plt.subplot(1, 3, 1)",
    "file": "docs\\TUTORIAL.md",
    "line": 246
  },
  {
    "area": "visualization_monitoring",
    "text": "# Spike raster",
    "file": "docs\\TUTORIAL.md",
    "line": 251
  },
  {
    "area": "visualization_monitoring",
    "text": "plt.subplot(1, 3, 2)",
    "file": "docs\\TUTORIAL.md",
    "line": 252
  },
  {
    "area": "visualization_monitoring",
    "text": "plt.title('Spike Raster')",
    "file": "docs\\TUTORIAL.md",
    "line": 257
  },
  {
    "area": "visualization_monitoring",
    "text": "plt.subplot(1, 3, 3)",
    "file": "docs\\TUTORIAL.md",
    "line": 262
  },
  {
    "area": "sensory_encoding",
    "text": "Convert audio signals to spike trains using cochlear-like processing.",
    "file": "docs\\TUTORIAL.md",
    "line": 276
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import CochlearEncoder",
    "file": "docs\\TUTORIAL.md",
    "line": 279
  },
  {
    "area": "sensory_encoding",
    "text": "# Create auditory encoder",
    "file": "docs\\TUTORIAL.md",
    "line": 281
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = CochlearEncoder(frequency_bands=64)",
    "file": "docs\\TUTORIAL.md",
    "line": 282
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(audio)",
    "file": "docs\\TUTORIAL.md",
    "line": 292
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import MultiModalEncoder, RetinalEncoder, CochlearEncoder, SomatosensoryEncoder",
    "file": "docs\\TUTORIAL.md",
    "line": 301
  },
  {
    "area": "sensory_encoding",
    "text": "# Create multi-modal encoder",
    "file": "docs\\TUTORIAL.md",
    "line": 303
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = MultiModalEncoder({",
    "file": "docs\\TUTORIAL.md",
    "line": 304
  },
  {
    "area": "sensory_encoding",
    "text": "'vision': RetinalEncoder(resolution=(32, 32)),",
    "file": "docs\\TUTORIAL.md",
    "line": 305
  },
  {
    "area": "sensory_encoding",
    "text": "'auditory': CochlearEncoder(frequency_bands=64),",
    "file": "docs\\TUTORIAL.md",
    "line": 306
  },
  {
    "area": "sensory_encoding",
    "text": "'tactile': SomatosensoryEncoder(sensor_grid=(16, 16))",
    "file": "docs\\TUTORIAL.md",
    "line": 307
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(inputs)",
    "file": "docs\\TUTORIAL.md",
    "line": 318
  },
  {
    "area": "neuromodulation",
    "text": "### Understanding Neuromodulatory Systems",
    "file": "docs\\TUTORIAL.md",
    "line": 324
  },
  {
    "area": "neuromodulation",
    "text": "The system includes four major neuromodulatory systems:",
    "file": "docs\\TUTORIAL.md",
    "line": 326
  },
  {
    "area": "neuromodulation",
    "text": "1. **Dopamine**: Reward prediction and learning",
    "file": "docs\\TUTORIAL.md",
    "line": 328
  },
  {
    "area": "neuromodulation",
    "text": "2. **Serotonin**: Mood and behavioral state",
    "file": "docs\\TUTORIAL.md",
    "line": 329
  },
  {
    "area": "neuromodulation",
    "text": "3. **Acetylcholine**: Attention and learning rate",
    "file": "docs\\TUTORIAL.md",
    "line": 330
  },
  {
    "area": "neuromodulation",
    "text": "4. **Norepinephrine**: Arousal and vigilance",
    "file": "docs\\TUTORIAL.md",
    "line": 331
  },
  {
    "area": "neuromodulation",
    "text": "### Using Neuromodulatory Controllers",
    "file": "docs\\TUTORIAL.md",
    "line": 333
  },
  {
    "area": "neuromodulation",
    "text": "from core.neuromodulation import NeuromodulatoryController, NeuromodulatorType",
    "file": "docs\\TUTORIAL.md",
    "line": 336
  },
  {
    "area": "neuromodulation",
    "text": "# Create neuromodulatory controller",
    "file": "docs\\TUTORIAL.md",
    "line": 338
  },
  {
    "area": "neuromodulation",
    "text": "controller = NeuromodulatoryController()",
    "file": "docs\\TUTORIAL.md",
    "line": 339
  },
  {
    "area": "neuromodulation",
    "text": "# Update neuromodulatory systems",
    "file": "docs\\TUTORIAL.md",
    "line": 341
  },
  {
    "area": "neuromodulation",
    "text": "reward=1.0,",
    "file": "docs\\TUTORIAL.md",
    "line": 344
  },
  {
    "area": "neuromodulation",
    "text": "expected_reward=0.5,",
    "file": "docs\\TUTORIAL.md",
    "line": 345
  },
  {
    "area": "neuromodulation",
    "text": "print(f\"Dopamine: {levels[NeuromodulatorType.DOPAMINE]:.3f}\")",
    "file": "docs\\TUTORIAL.md",
    "line": 355
  },
  {
    "area": "neuromodulation",
    "text": "print(f\"Serotonin: {levels[NeuromodulatorType.SEROTONIN]:.3f}\")",
    "file": "docs\\TUTORIAL.md",
    "line": 356
  },
  {
    "area": "neuromodulation",
    "text": "print(f\"Acetylcholine: {levels[NeuromodulatorType.ACETYLCHOLINE]:.3f}\")",
    "file": "docs\\TUTORIAL.md",
    "line": 357
  },
  {
    "area": "neuromodulation",
    "text": "print(f\"Norepinephrine: {levels[NeuromodulatorType.NOREPINEPHRINE]:.3f}\")",
    "file": "docs\\TUTORIAL.md",
    "line": 358
  },
  {
    "area": "api_docs",
    "text": "from api.neuromorphic_api import SensorimotorSystem",
    "file": "docs\\TUTORIAL.md",
    "line": 388
  },
  {
    "area": "neuromodulation",
    "text": "'reward': 1.0 if i % 2 == 0 else -0.2",
    "file": "docs\\TUTORIAL.md",
    "line": 401
  },
  {
    "area": "visualization_monitoring",
    "text": "### Network Visualization",
    "file": "docs\\TUTORIAL.md",
    "line": 418
  },
  {
    "area": "api_docs",
    "text": "from api.neuromorphic_api import NeuromorphicVisualizer",
    "file": "docs\\TUTORIAL.md",
    "line": 421
  },
  {
    "area": "visualization_monitoring",
    "text": "# Create network for visualization",
    "file": "docs\\TUTORIAL.md",
    "line": 426
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\TUTORIAL.md",
    "line": 427
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\TUTORIAL.md",
    "line": 428
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"input\", 20, \"rate\")",
    "file": "docs\\TUTORIAL.md",
    "line": 429
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"hidden\", 10, \"adex\")",
    "file": "docs\\TUTORIAL.md",
    "line": 430
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"output\", 5)",
    "file": "docs\\TUTORIAL.md",
    "line": 431
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"input\", \"hidden\", \"feedforward\")",
    "file": "docs\\TUTORIAL.md",
    "line": 432
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"hidden\", \"output\", \"feedforward\")",
    "file": "docs\\TUTORIAL.md",
    "line": 433
  },
  {
    "area": "visualization_monitoring",
    "text": "visualizer.plot_network_structure(api.network)",
    "file": "docs\\TUTORIAL.md",
    "line": 436
  },
  {
    "area": "visualization_monitoring",
    "text": "visualizer.plot_weight_matrices(api.network)",
    "file": "docs\\TUTORIAL.md",
    "line": 437
  },
  {
    "area": "edge_features",
    "text": "## Jetson Deployment",
    "file": "docs\\TUTORIAL.md",
    "line": 440
  },
  {
    "area": "edge_features",
    "text": "### Basic Jetson Setup",
    "file": "docs\\TUTORIAL.md",
    "line": 442
  },
  {
    "area": "edge_features",
    "text": "from jetson_optimization import JetsonOptimizer, JetsonSensorimotorSystem",
    "file": "docs\\TUTORIAL.md",
    "line": 445
  },
  {
    "area": "edge_features",
    "text": "# Create Jetson optimizer",
    "file": "docs\\TUTORIAL.md",
    "line": 447
  },
  {
    "area": "edge_features",
    "text": "optimizer = JetsonOptimizer()",
    "file": "docs\\TUTORIAL.md",
    "line": 448
  },
  {
    "area": "performance",
    "text": "print(f\"Available memory: {system_info['memory_available'] / (1024**3):.2f} GB\")",
    "file": "docs\\TUTORIAL.md",
    "line": 453
  },
  {
    "area": "edge_features",
    "text": "# Create Jetson-optimized system",
    "file": "docs\\TUTORIAL.md",
    "line": 456
  },
  {
    "area": "edge_features",
    "text": "jetson_system = JetsonSensorimotorSystem(use_gpu=True)",
    "file": "docs\\TUTORIAL.md",
    "line": 457
  },
  {
    "area": "edge_features",
    "text": "jetson_system.initialize()",
    "file": "docs\\TUTORIAL.md",
    "line": 458
  },
  {
    "area": "edge_features",
    "text": "results = jetson_system.run_inference(inputs, duration=50.0)",
    "file": "docs\\TUTORIAL.md",
    "line": 467
  },
  {
    "area": "edge_features",
    "text": "metrics = results.get('jetson_metrics', {})",
    "file": "docs\\TUTORIAL.md",
    "line": 470
  },
  {
    "area": "performance",
    "text": "print(f\"Memory usage: {metrics.get('current_memory', 0):.1f}%\")",
    "file": "docs\\TUTORIAL.md",
    "line": 472
  },
  {
    "area": "edge_features",
    "text": "print(f\"Power consumption: {metrics.get('current_power', 0):.2f}W\")",
    "file": "docs\\TUTORIAL.md",
    "line": 474
  },
  {
    "area": "visualization_monitoring",
    "text": "### Performance Monitoring",
    "file": "docs\\TUTORIAL.md",
    "line": 477
  },
  {
    "area": "edge_features",
    "text": "results = jetson_system.run_inference(inputs, duration=10.0)",
    "file": "docs\\TUTORIAL.md",
    "line": 487
  },
  {
    "area": "edge_features",
    "text": "metrics = results.get('jetson_metrics', {})",
    "file": "docs\\TUTORIAL.md",
    "line": 490
  },
  {
    "area": "performance",
    "text": "print(f\"  Memory: {metrics.get('current_memory', 0):.1f}%\")",
    "file": "docs\\TUTORIAL.md",
    "line": 495
  },
  {
    "area": "neuron_models",
    "text": "- Use appropriate neuron models for your application",
    "file": "docs\\TUTORIAL.md",
    "line": 507
  },
  {
    "area": "performance",
    "text": "- Balance biological realism with computational efficiency",
    "file": "docs\\TUTORIAL.md",
    "line": 508
  },
  {
    "area": "plasticity",
    "text": "- Adjust STDP parameters based on your task",
    "file": "docs\\TUTORIAL.md",
    "line": 512
  },
  {
    "area": "neuron_models",
    "text": "- Use LIF neurons for large networks",
    "file": "docs\\TUTORIAL.md",
    "line": 518
  },
  {
    "area": "performance",
    "text": "- Reduce connection probability for efficiency",
    "file": "docs\\TUTORIAL.md",
    "line": 519
  },
  {
    "area": "edge_features",
    "text": "- Monitor memory usage on resource-constrained systems",
    "file": "docs\\TUTORIAL.md",
    "line": 520
  },
  {
    "area": "edge_features",
    "text": "### 4. Jetson Deployment",
    "file": "docs\\TUTORIAL.md",
    "line": 522
  },
  {
    "area": "edge_features",
    "text": "- Monitor temperature and power consumption",
    "file": "docs\\TUTORIAL.md",
    "line": 524
  },
  {
    "area": "edge_features",
    "text": "- Reduce network size for edge deployment",
    "file": "docs\\TUTORIAL.md",
    "line": 525
  },
  {
    "area": "performance",
    "text": "### Memory Issues",
    "file": "docs\\TUTORIAL.md",
    "line": 530
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"input\", 25, \"rate\")  # Reduced from 50",
    "file": "docs\\TUTORIAL.md",
    "line": 534
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"hidden\", 12, \"lif\")  # Use LIF instead of AdEx",
    "file": "docs\\TUTORIAL.md",
    "line": 535
  },
  {
    "area": "performance",
    "text": "# Clear memory",
    "file": "docs\\TUTORIAL.md",
    "line": 537
  },
  {
    "area": "plasticity",
    "text": "# Adjust STDP parameters",
    "file": "docs\\TUTORIAL.md",
    "line": 545
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"input\", \"hidden\", \"feedforward\",",
    "file": "docs\\TUTORIAL.md",
    "line": 546
  },
  {
    "area": "plasticity",
    "text": "synapse_type=\"stdp\",",
    "file": "docs\\TUTORIAL.md",
    "line": 547
  },
  {
    "area": "plasticity",
    "text": "tau_stdp=30.0)  # Increased from 20.0",
    "file": "docs\\TUTORIAL.md",
    "line": 550
  },
  {
    "area": "edge_features",
    "text": "### Jetson Performance",
    "file": "docs\\TUTORIAL.md",
    "line": 553
  },
  {
    "area": "edge_features",
    "text": "# Check system resources",
    "file": "docs\\TUTORIAL.md",
    "line": 556
  },
  {
    "area": "performance",
    "text": "if system_info['memory_available'] < 1 * (1024**3):  # Less than 1GB",
    "file": "docs\\TUTORIAL.md",
    "line": 562
  },
  {
    "area": "performance",
    "text": "print(\"Warning: Low memory\")",
    "file": "docs\\TUTORIAL.md",
    "line": 563
  },
  {
    "area": "api_docs",
    "text": "3. **Build custom applications**: Use the API to create your own neuromorphic systems",
    "file": "docs\\TUTORIAL.md",
    "line": 571
  },
  {
    "area": "edge_features",
    "text": "4. **Deploy to Jetson**: Follow the Jetson deployment guide",
    "file": "docs\\TUTORIAL.md",
    "line": 572
  },
  {
    "area": "edge_features",
    "text": "For more information, see the [API Reference](API_REFERENCE.md) and [Jetson Deployment Guide](../JETSON_DEPLOYMENT.md).",
    "file": "docs\\TUTORIAL.md",
    "line": 575
  },
  {
    "area": "api_docs",
    "text": "# Sphinx API Documentation Generation Report",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 1
  },
  {
    "area": "api_docs",
    "text": "- **sphinx.ext.autodoc**: Enabled for automatic documentation extraction from docstrings",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 10
  },
  {
    "area": "api_docs",
    "text": "- **sphinx_autodoc_typehints**: Added for automatic type hint documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 12
  },
  {
    "area": "api_docs",
    "text": "'sphinx_autodoc_typehints',  # Automatic type hints in documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 20
  },
  {
    "area": "neuron_models",
    "text": "typehints_fully_qualified = False",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 41
  },
  {
    "area": "api_docs",
    "text": "### 2. \u2705 Generated API Reference Documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 46
  },
  {
    "area": "api_docs",
    "text": "Successfully ran `sphinx-apidoc` to create `.rst` stubs for all modules:",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 47
  },
  {
    "area": "api_docs",
    "text": "- **core** module documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 48
  },
  {
    "area": "api_docs",
    "text": "- **api** module documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 49
  },
  {
    "area": "api_docs",
    "text": "- **engine** module documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 50
  },
  {
    "area": "api_docs",
    "text": "- **tests** module documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 51
  },
  {
    "area": "api_docs",
    "text": "### 3. \u2705 Built HTML Documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 54
  },
  {
    "area": "api_docs",
    "text": "- Complete API reference generated",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 58
  },
  {
    "area": "sensory_encoding",
    "text": "2. **Non-existent Class Import**: Fixed `SensoryEncoder` import error in `api/neuromorphic_system.py`",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 64
  },
  {
    "area": "sensory_encoding",
    "text": "3. **Incorrect Method Signatures**: Fixed `MultiModalEncoder` initialization and method calls",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 65
  },
  {
    "area": "api_docs",
    "text": "### Documentation Structure Issues Fixed:",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 73
  },
  {
    "area": "api_docs",
    "text": "- Properly structured the documentation hierarchy",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 75
  },
  {
    "area": "api_docs",
    "text": "## Generated Documentation Files",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 83
  },
  {
    "area": "api_docs",
    "text": "The following HTML documentation files were successfully generated:",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 85
  },
  {
    "area": "api_docs",
    "text": "- `build/html/index.html` - Main documentation page",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 86
  },
  {
    "area": "api_docs",
    "text": "- `build/html/api.html` - API module documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 88
  },
  {
    "area": "api_docs",
    "text": "- `build/html/core.html` - Core module documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 89
  },
  {
    "area": "api_docs",
    "text": "- `build/html/engine.html` - Engine module documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 90
  },
  {
    "area": "api_docs",
    "text": "1. **Regular Documentation Updates**: Run `sphinx-apidoc` whenever new modules are added",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 102
  },
  {
    "area": "api_docs",
    "text": "3. **Type Hints**: Maintain type hints in all function signatures for better documentation",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 104
  },
  {
    "area": "api_docs",
    "text": "The Sphinx API reference documentation has been successfully configured and generated. All modules are properly documented with Google-style docstring support and automatic type hint extraction. The documentation builds without warnings and provides comprehensive API reference for the neuromorphic system project.",
    "file": "docs\\docs\\sphinx_api_documentation_report.md",
    "line": 109
  },
  {
    "area": "edge_features",
    "text": "- (Optional) NVIDIA Jetson Nano for edge deployment",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 12
  },
  {
    "area": "edge_features",
    "text": "# Or install with Jetson support",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 36
  },
  {
    "area": "edge_features",
    "text": "pip install -e \".[jetson]\"",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 37
  },
  {
    "area": "visualization_monitoring",
    "text": "\u2713 Matplotlib installed",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 85
  },
  {
    "area": "neuron_models",
    "text": "\u2713 Neuron models working",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 87
  },
  {
    "area": "api_docs",
    "text": "from api.neuromorphic_api import NeuromorphicAPI",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 97
  },
  {
    "area": "api_docs",
    "text": "# Initialize the API",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 99
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 100
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 103
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"input\", neurons=100, encoding_type=\"rate\")",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 106
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"hidden\", neurons=50, neuron_type=\"adex\")",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 107
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"output\", neurons=10)",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 108
  },
  {
    "area": "plasticity",
    "text": "api.connect_layers(\"input\", \"hidden\", \"feedforward\", synapse_type=\"stdp\")",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 111
  },
  {
    "area": "plasticity",
    "text": "api.connect_layers(\"hidden\", \"output\", \"feedforward\", synapse_type=\"stdp\")",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 112
  },
  {
    "area": "simulation_modes",
    "text": "# Run a simulation for 1000ms",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 114
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(duration=1000.0)",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 115
  },
  {
    "area": "simulation_modes",
    "text": "print(f\"Simulation completed in {results['duration']} ms\")",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 118
  },
  {
    "area": "neuron_models",
    "text": "### Neuron Models",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 125
  },
  {
    "area": "neuron_models",
    "text": "The system provides three biologically plausible neuron models:",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 127
  },
  {
    "area": "neuron_models",
    "text": "1. **AdEx (Adaptive Exponential)**: Most biologically realistic, includes adaptation",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 129
  },
  {
    "area": "neuron_models",
    "text": "2. **LIF (Leaky Integrate-and-Fire)**: Simple and efficient for large-scale simulations",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 130
  },
  {
    "area": "neuron_models",
    "text": "3. **HH (Hodgkin-Huxley)**: Full ion channel dynamics, most computationally expensive",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 131
  },
  {
    "area": "plasticity",
    "text": "Various forms of synaptic plasticity are available:",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 135
  },
  {
    "area": "plasticity",
    "text": "2. **STDP**: Spike-Timing-Dependent Plasticity for Hebbian learning",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 138
  },
  {
    "area": "plasticity",
    "text": "3. **STP**: Short-Term Plasticity with depression and facilitation",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 139
  },
  {
    "area": "plasticity",
    "text": "4. **RSTDP**: Reward-modulated STDP for reinforcement learning",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 140
  },
  {
    "area": "simulation_modes",
    "text": "# Run simulation with external input",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 162
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 163
  },
  {
    "area": "visualization_monitoring",
    "text": "Basic visualization of network activity:",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 171
  },
  {
    "area": "visualization_monitoring",
    "text": "import matplotlib.pyplot as plt",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 174
  },
  {
    "area": "performance",
    "text": "### Issue: Memory errors with large networks",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 195
  },
  {
    "area": "edge_features",
    "text": "**Solution**: Reduce network size or use the Jetson optimization features.",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 196
  },
  {
    "area": "simulation_modes",
    "text": "### Issue: Slow simulation",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 198
  },
  {
    "area": "neuron_models",
    "text": "**Solution**: Use LIF neurons instead of HH, or enable GPU acceleration if available.",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 199
  },
  {
    "area": "plasticity",
    "text": "3. Implement [learning and plasticity](03_learning_plasticity.md)",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 207
  },
  {
    "area": "edge_features",
    "text": "5. Deploy to [edge devices](05_edge_deployment.md)",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 209
  },
  {
    "area": "api_docs",
    "text": "2. Review the [API Reference](../API_REFERENCE.md)",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 215
  },
  {
    "area": "edge_features",
    "text": "## Additional Resources",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 219
  },
  {
    "area": "api_docs",
    "text": "- [Research Papers](../references.md)",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 224
  },
  {
    "area": "api_docs",
    "text": "*Continue to the next tutorial: [Sensory Encoding \u2192](02_sensory_encoding.md)*",
    "file": "docs\\tutorials\\01_getting_started.md",
    "line": 228
  },
  {
    "area": "api_docs",
    "text": "Sensory encoding is the process of converting continuous sensory signals (images, sounds, touch) into discrete spike trains that spiking neural networks can process. This tutorial covers the various encoding methods available in the system.",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 7
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import RateEncoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 16
  },
  {
    "area": "sensory_encoding",
    "text": "# Create rate encoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 18
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = RateEncoder(num_neurons=100, max_rate=100.0)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 19
  },
  {
    "area": "sensory_encoding",
    "text": "spike_times = encoder.encode(intensity, duration=100.0)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 23
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import TemporalEncoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 37
  },
  {
    "area": "sensory_encoding",
    "text": "# Create temporal encoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 39
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = TemporalEncoder(num_neurons=100, time_window=10.0)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 40
  },
  {
    "area": "sensory_encoding",
    "text": "spike_times = encoder.encode(value)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 44
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import PopulationEncoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 57
  },
  {
    "area": "sensory_encoding",
    "text": "# Create population encoder with Gaussian tuning curves",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 59
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = PopulationEncoder(",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 60
  },
  {
    "area": "sensory_encoding",
    "text": "spike_rates = encoder.encode(value)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 69
  },
  {
    "area": "sensory_encoding",
    "text": "### Retinal Encoding",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 79
  },
  {
    "area": "sensory_encoding",
    "text": "Simulates retinal processing with center-surround receptive fields:",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 81
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import RetinalEncoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 84
  },
  {
    "area": "sensory_encoding",
    "text": "# Create retinal encoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 87
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = RetinalEncoder(",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 88
  },
  {
    "area": "sensory_encoding",
    "text": "spike_trains = encoder.encode(image, duration=100.0)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 96
  },
  {
    "area": "sensory_encoding",
    "text": "from core.enhanced_encoding import DVSEncoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 108
  },
  {
    "area": "sensory_encoding",
    "text": "# Create DVS encoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 110
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = DVSEncoder(",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 111
  },
  {
    "area": "sensory_encoding",
    "text": "events = encoder.encode_difference(previous_frame, current_frame)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 121
  },
  {
    "area": "sensory_encoding",
    "text": "### Cochlear Encoding",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 127
  },
  {
    "area": "sensory_encoding",
    "text": "Simulates cochlear processing with frequency decomposition:",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 129
  },
  {
    "area": "sensory_encoding",
    "text": "from core.enhanced_encoding import CochlearEncoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 132
  },
  {
    "area": "sensory_encoding",
    "text": "# Create cochlear encoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 135
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = CochlearEncoder(",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 136
  },
  {
    "area": "sensory_encoding",
    "text": "spike_trains = encoder.encode(audio)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 147
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import OnsetEncoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 156
  },
  {
    "area": "sensory_encoding",
    "text": "# Create onset encoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 158
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = OnsetEncoder(",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 159
  },
  {
    "area": "sensory_encoding",
    "text": "onsets = encoder.encode(audio)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 165
  },
  {
    "area": "sensory_encoding",
    "text": "from core.enhanced_encoding import MechanoreceptorEncoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 176
  },
  {
    "area": "sensory_encoding",
    "text": "# Create encoder for different receptor types",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 178
  },
  {
    "area": "sensory_encoding",
    "text": "sa1_encoder = MechanoreceptorEncoder(",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 179
  },
  {
    "area": "sensory_encoding",
    "text": "ra_encoder = MechanoreceptorEncoder(",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 184
  },
  {
    "area": "api_docs",
    "text": "receptor_type=\"RA\",   # Rapidly adapting",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 185
  },
  {
    "area": "sensory_encoding",
    "text": "sa1_spikes = sa1_encoder.encode(pressure)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 191
  },
  {
    "area": "sensory_encoding",
    "text": "ra_spikes = ra_encoder.encode(pressure)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 192
  },
  {
    "area": "sensory_encoding",
    "text": "## Multimodal Integration",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 198
  },
  {
    "area": "api_docs",
    "text": "from api.neuromorphic_api import NeuromorphicAPI",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 203
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 206
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 207
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"visual\", 1024, \"rate\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 210
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"auditory\", 256, \"temporal\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 211
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"tactile\", 100, \"population\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 212
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"integration\", 500, \"adex\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 215
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"visual\", \"integration\", \"feedforward\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 218
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"auditory\", \"integration\", \"feedforward\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 219
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"tactile\", \"integration\", \"feedforward\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 220
  },
  {
    "area": "sensory_encoding",
    "text": "# Prepare multimodal input",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 222
  },
  {
    "area": "sensory_encoding",
    "text": "# Run simulation with multimodal input",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 227
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 228
  },
  {
    "area": "sensory_encoding",
    "text": "## Custom Encoders",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 238
  },
  {
    "area": "sensory_encoding",
    "text": "Creating your own encoder for specific applications:",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 240
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import Encoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 243
  },
  {
    "area": "sensory_encoding",
    "text": "class CustomEncoder(Encoder):",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 246
  },
  {
    "area": "sensory_encoding",
    "text": "\"\"\"Custom encoder for specific sensor type.\"\"\"",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 247
  },
  {
    "area": "sensory_encoding",
    "text": "# Use custom encoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 272
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = CustomEncoder(num_neurons=50)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 273
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(data=0.7, duration=100.0)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 274
  },
  {
    "area": "performance",
    "text": "- Balance accuracy with efficiency",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 281
  },
  {
    "area": "performance",
    "text": "- Reduces energy consumption and improves efficiency",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 289
  },
  {
    "area": "sensory_encoding",
    "text": "# Encode with retinal encoder",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 304
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = RetinalEncoder(resolution=(32, 32))",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 305
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(img_array, duration=100.0)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 306
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 309
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 310
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"retina\", 1024, \"custom\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 311
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"v1\", 256, \"adex\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 312
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"classification\", 10)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 313
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"retina\", \"v1\", \"feedforward\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 315
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"v1\", \"classification\", \"feedforward\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 316
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(100.0, external_inputs={\"retina\": spikes})",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 318
  },
  {
    "area": "sensory_encoding",
    "text": "# Encode with cochlear model",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 330
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = CochlearEncoder(num_channels=64, sample_rate=sr)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 331
  },
  {
    "area": "sensory_encoding",
    "text": "spikes = encoder.encode(audio)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 332
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 335
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 336
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"cochlea\", 64, \"custom\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 337
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"auditory_cortex\", 128, \"izhikevich\")",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 338
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"keywords\", 10)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 339
  },
  {
    "area": "simulation_modes",
    "text": "# ... continue with network setup and simulation",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 341
  },
  {
    "area": "plasticity",
    "text": "- Learn about [Learning and Plasticity](03_learning_plasticity.md)",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 346
  },
  {
    "area": "plasticity",
    "text": "*\u2190 [Getting Started](01_getting_started.md) | [Learning and Plasticity \u2192](03_learning_plasticity.md)*",
    "file": "docs\\tutorials\\02_sensory_encoding.md",
    "line": 352
  },
  {
    "area": "plasticity",
    "text": "# Learning and Plasticity",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 1
  },
  {
    "area": "plasticity",
    "text": "Comprehensive guide to implementing learning mechanisms and synaptic plasticity in neuromorphic networks.",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 3
  },
  {
    "area": "plasticity",
    "text": "Synaptic plasticity is the biological basis of learning and memory. This tutorial covers the various plasticity mechanisms implemented in the system, from basic Hebbian learning to complex neuromodulated plasticity.",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 7
  },
  {
    "area": "plasticity",
    "text": "## Spike-Timing-Dependent Plasticity (STDP)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 9
  },
  {
    "area": "plasticity",
    "text": "### Basic STDP",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 11
  },
  {
    "area": "plasticity",
    "text": "STDP modifies synaptic weights based on the relative timing of pre- and post-synaptic spikes:",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 13
  },
  {
    "area": "plasticity",
    "text": "from core.synapses import STDP_Synapse, SynapseType",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 16
  },
  {
    "area": "plasticity",
    "text": "# Create STDP synapse",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 18
  },
  {
    "area": "plasticity",
    "text": "synapse = STDP_Synapse(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 19
  },
  {
    "area": "plasticity",
    "text": "tau_stdp=20.0,  # Time constant",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 25
  },
  {
    "area": "plasticity",
    "text": "### Asymmetric STDP",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 44
  },
  {
    "area": "plasticity",
    "text": "from core.learning import AsymmetricSTDP",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 49
  },
  {
    "area": "plasticity",
    "text": "# Create asymmetric STDP rule",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 51
  },
  {
    "area": "plasticity",
    "text": "plasticity = AsymmetricSTDP(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 52
  },
  {
    "area": "plasticity",
    "text": "synapse.set_plasticity_rule(plasticity)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 62
  },
  {
    "area": "plasticity",
    "text": "### Triplet STDP",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 65
  },
  {
    "area": "plasticity",
    "text": "from core.learning import TripletSTDP",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 70
  },
  {
    "area": "plasticity",
    "text": "# Create triplet STDP rule",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 72
  },
  {
    "area": "plasticity",
    "text": "plasticity = TripletSTDP(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 73
  },
  {
    "area": "plasticity",
    "text": "plasticity.add_pre_spike(t=10.0)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 85
  },
  {
    "area": "plasticity",
    "text": "plasticity.add_post_spike(t=12.0)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 86
  },
  {
    "area": "plasticity",
    "text": "plasticity.add_pre_spike(t=14.0)  # Triplet formed",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 87
  },
  {
    "area": "plasticity",
    "text": "weight_change = plasticity.compute_weight_change()",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 89
  },
  {
    "area": "plasticity",
    "text": "## Short-Term Plasticity (STP)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 93
  },
  {
    "area": "plasticity",
    "text": "STP causes temporary changes in synaptic efficacy:",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 97
  },
  {
    "area": "plasticity",
    "text": "from core.synapses import ShortTermPlasticitySynapse",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 100
  },
  {
    "area": "plasticity",
    "text": "# Create STP synapse with depression",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 102
  },
  {
    "area": "plasticity",
    "text": "depressing_synapse = ShortTermPlasticitySynapse(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 103
  },
  {
    "area": "plasticity",
    "text": "### Mixed STP",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 119
  },
  {
    "area": "plasticity",
    "text": "mixed_synapse = ShortTermPlasticitySynapse(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 125
  },
  {
    "area": "neuromodulation",
    "text": "## Reward-Modulated Learning",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 149
  },
  {
    "area": "plasticity",
    "text": "### Basic Reward-Modulated STDP",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 151
  },
  {
    "area": "plasticity",
    "text": "Combining STDP with reward signals:",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 153
  },
  {
    "area": "plasticity",
    "text": "from core.synapses import RSTDP_Synapse",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 156
  },
  {
    "area": "neuromodulation",
    "text": "# Create reward-modulated synapse",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 158
  },
  {
    "area": "plasticity",
    "text": "rstdp_synapse = RSTDP_Synapse(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 159
  },
  {
    "area": "plasticity",
    "text": "# Regular STDP creates eligibility trace",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 168
  },
  {
    "area": "plasticity",
    "text": "rstdp_synapse.pre_spike(t=10.0)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 169
  },
  {
    "area": "plasticity",
    "text": "rstdp_synapse.post_spike(t=12.0)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 170
  },
  {
    "area": "neuromodulation",
    "text": "# Reward signal modulates weight change",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 172
  },
  {
    "area": "plasticity",
    "text": "rstdp_synapse.apply_reward(reward=1.0, t=15.0)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 173
  },
  {
    "area": "plasticity",
    "text": "print(f\"Weight after reward: {rstdp_synapse.weight}\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 174
  },
  {
    "area": "neuromodulation",
    "text": "# Punishment (negative reward)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 176
  },
  {
    "area": "plasticity",
    "text": "rstdp_synapse.apply_reward(reward=-0.5, t=20.0)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 177
  },
  {
    "area": "plasticity",
    "text": "print(f\"Weight after punishment: {rstdp_synapse.weight}\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 178
  },
  {
    "area": "neuromodulation",
    "text": "tau_dopamine=200.0,",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 192
  },
  {
    "area": "neuromodulation",
    "text": "baseline_dopamine=0.1",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 193
  },
  {
    "area": "neuromodulation",
    "text": "# 2. Delayed reward signal",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 200
  },
  {
    "area": "neuromodulation",
    "text": "learning_rule.set_dopamine(level=1.0, t=100.0)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 201
  },
  {
    "area": "plasticity",
    "text": "## Homeostatic Plasticity",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 208
  },
  {
    "area": "neuromodulation",
    "text": "# Create homeostatic controller",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 217
  },
  {
    "area": "plasticity",
    "text": "### Intrinsic Plasticity",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 234
  },
  {
    "area": "plasticity",
    "text": "from core.learning import IntrinsicPlasticity",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 239
  },
  {
    "area": "plasticity",
    "text": "# Create intrinsic plasticity mechanism",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 241
  },
  {
    "area": "plasticity",
    "text": "ip = IntrinsicPlasticity(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 242
  },
  {
    "area": "plasticity",
    "text": "## Structural Plasticity",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 254
  },
  {
    "area": "plasticity",
    "text": "from core.learning import StructuralPlasticity",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 261
  },
  {
    "area": "plasticity",
    "text": "# Configure structural plasticity",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 263
  },
  {
    "area": "plasticity",
    "text": "structural = StructuralPlasticity(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 264
  },
  {
    "area": "api_docs",
    "text": "from api.neuromorphic_api import NeuromorphicAPI",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 298
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 302
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 303
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"input\", 100, \"rate\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 306
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"hidden\", 50, \"adex\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 307
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"output\", 10)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 308
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"input\", \"hidden\", \"feedforward\",",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 311
  },
  {
    "area": "plasticity",
    "text": "synapse_type=\"stdp\", learning_enabled=True)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 312
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"hidden\", \"output\", \"feedforward\",",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 313
  },
  {
    "area": "plasticity",
    "text": "synapse_type=\"rstdp\", learning_enabled=True)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 314
  },
  {
    "area": "simulation_modes",
    "text": "# Run simulation with supervision",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 327
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 328
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 347
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 348
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"input\", 100, \"rate\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 351
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"som\", 10*10, \"lif\")  # 10x10 grid",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 352
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"input\", \"som\", \"all_to_all\",",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 355
  },
  {
    "area": "plasticity",
    "text": "synapse_type=\"stdp\", learning_enabled=True)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 356
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"som\", \"som\", \"lateral_inhibition\",",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 357
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 367
  },
  {
    "area": "neuromodulation",
    "text": "Learning from rewards:",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 380
  },
  {
    "area": "api_docs",
    "text": "api = NeuromorphicAPI()",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 384
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 385
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"state\", 50, \"population\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 388
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"critic\", 20, \"adex\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 389
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"actor\", 30, \"adex\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 390
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"action\", 4)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 391
  },
  {
    "area": "neuromodulation",
    "text": "# Configure reward-modulated connections",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 393
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"state\", \"critic\", \"feedforward\",",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 394
  },
  {
    "area": "plasticity",
    "text": "synapse_type=\"rstdp\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 395
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"state\", \"actor\", \"feedforward\",",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 396
  },
  {
    "area": "plasticity",
    "text": "synapse_type=\"rstdp\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 397
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"actor\", \"action\", \"feedforward\",",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 398
  },
  {
    "area": "plasticity",
    "text": "synapse_type=\"rstdp\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 399
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 408
  },
  {
    "area": "neuromodulation",
    "text": "next_state, reward = environment.step(action)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 415
  },
  {
    "area": "neuromodulation",
    "text": "# Apply reward signal",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 417
  },
  {
    "area": "api_docs",
    "text": "api.apply_neuromodulation(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 418
  },
  {
    "area": "neuromodulation",
    "text": "dopamine_level=reward,",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 419
  },
  {
    "area": "neuromodulation",
    "text": "# Update weights based on reward",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 423
  },
  {
    "area": "api_docs",
    "text": "api.update_weights(learning_rate=0.01)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 424
  },
  {
    "area": "neuromodulation",
    "text": "print(f\"Step {step}: Reward = {reward:.2f}\")",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 427
  },
  {
    "area": "plasticity",
    "text": "### Meta-Plasticity",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 432
  },
  {
    "area": "plasticity",
    "text": "Plasticity of plasticity:",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 434
  },
  {
    "area": "plasticity",
    "text": "from core.learning import MetaPlasticity",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 437
  },
  {
    "area": "plasticity",
    "text": "# Create meta-plasticity controller",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 439
  },
  {
    "area": "plasticity",
    "text": "meta = MetaPlasticity(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 440
  },
  {
    "area": "performance",
    "text": "Memory consolidation and transfer:",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 454
  },
  {
    "area": "performance",
    "text": "from core.memory import MemoryConsolidation",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 457
  },
  {
    "area": "performance",
    "text": "consolidation = MemoryConsolidation(",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 460
  },
  {
    "area": "performance",
    "text": "# Retrieve consolidated memory",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 473
  },
  {
    "area": "performance",
    "text": "memory = consolidation.retrieve(cue)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 474
  },
  {
    "area": "plasticity",
    "text": "1. **Choose appropriate plasticity rules**",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 479
  },
  {
    "area": "plasticity",
    "text": "- STDP for temporal pattern learning",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 480
  },
  {
    "area": "plasticity",
    "text": "- STP for dynamic filtering",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 481
  },
  {
    "area": "plasticity",
    "text": "- RSTDP for goal-directed learning",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 482
  },
  {
    "area": "plasticity",
    "text": "2. **Balance plasticity and stability**",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 484
  },
  {
    "area": "neuromodulation",
    "text": "- Use homeostatic mechanisms",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 485
  },
  {
    "area": "plasticity",
    "text": "- Consider meta-plasticity",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 487
  },
  {
    "area": "edge_features",
    "text": "- Learn about [Edge Deployment](05_edge_deployment.md)",
    "file": "docs\\tutorials\\03_learning_plasticity.md",
    "line": 502
  },
  {
    "area": "edge_features",
    "text": "# Edge Deployment",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 1
  },
  {
    "area": "edge_features",
    "text": "Deploy neuromorphic networks on edge devices including NVIDIA Jetson Nano and other embedded systems.",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 3
  },
  {
    "area": "edge_features",
    "text": "Edge deployment enables neuromorphic systems to run efficiently on resource-constrained devices, bringing brain-inspired computing to IoT, robotics, and embedded applications.",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 7
  },
  {
    "area": "edge_features",
    "text": "## Jetson Nano Deployment",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 9
  },
  {
    "area": "edge_features",
    "text": "- NVIDIA Jetson Nano (2GB or 4GB model)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 13
  },
  {
    "area": "edge_features",
    "text": "### Installation on Jetson",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 19
  },
  {
    "area": "visualization_monitoring",
    "text": "pip3 install numpy scipy matplotlib",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 27
  },
  {
    "area": "edge_features",
    "text": "pip3 install -e \".[jetson]\"",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 35
  },
  {
    "area": "edge_features",
    "text": "from scripts.jetson_optimization import JetsonOptimizer",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 41
  },
  {
    "area": "edge_features",
    "text": "optimizer = JetsonOptimizer()",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 44
  },
  {
    "area": "performance",
    "text": "print(f\"Available memory: {info['memory_available']} MB\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 48
  },
  {
    "area": "edge_features",
    "text": "# Set power mode",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 52
  },
  {
    "area": "edge_features",
    "text": "optimizer.set_power_mode(\"MAXN\")  # Maximum performance",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 53
  },
  {
    "area": "edge_features",
    "text": "# or \"5W\" for low power mode",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 54
  },
  {
    "area": "performance",
    "text": "### Memory-Efficient Networks",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 60
  },
  {
    "area": "api_docs",
    "text": "from api.neuromorphic_api import NeuromorphicAPI",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 63
  },
  {
    "area": "performance",
    "text": "# Create memory-optimized network",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 65
  },
  {
    "area": "edge_features",
    "text": "api = NeuromorphicAPI(device=\"jetson\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 66
  },
  {
    "area": "api_docs",
    "text": "api.set_precision(\"float16\")  # Half precision",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 69
  },
  {
    "area": "api_docs",
    "text": "api.create_network(max_neurons=500, max_synapses=5000)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 72
  },
  {
    "area": "neuron_models",
    "text": "# Use efficient neuron models",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 74
  },
  {
    "area": "neuron_models",
    "text": "api.add_sensory_layer(\"input\", 100, \"lif\")  # LIF is memory-efficient",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 75
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"hidden\", 50, \"lif\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 76
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"output\", 10)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 77
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"input\", \"hidden\", \"feedforward\",",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 80
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 84
  },
  {
    "area": "performance",
    "text": "record_potentials=False,  # Save memory",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 87
  },
  {
    "area": "api_docs",
    "text": "api.fine_tune(pruned_network, epochs=10)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 112
  },
  {
    "area": "simulation_modes",
    "text": "### 3. Event-Driven Processing",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 145
  },
  {
    "area": "simulation_modes",
    "text": "Minimize computation with event-based simulation:",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 147
  },
  {
    "area": "simulation_modes",
    "text": "from engine import Network, Simulator, SimulationMode",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 150
  },
  {
    "area": "simulation_modes",
    "text": "# Create event-driven network",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 152
  },
  {
    "area": "edge_features",
    "text": "network = Network(\"EdgeNetwork\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 153
  },
  {
    "area": "neuron_models",
    "text": "network.add_neuron_group(\"input\", 100, \"lif\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 154
  },
  {
    "area": "neuron_models",
    "text": "network.add_neuron_group(\"output\", 10, \"lif\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 155
  },
  {
    "area": "simulation_modes",
    "text": "# Use event-driven simulator",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 158
  },
  {
    "area": "simulation_modes",
    "text": "sim = Simulator(network, mode=SimulationMode.EVENT_DRIVEN)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 159
  },
  {
    "area": "performance",
    "text": "## Real-Time Processing",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 168
  },
  {
    "area": "performance",
    "text": "Process video in real-time:",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 172
  },
  {
    "area": "sensory_encoding",
    "text": "from core.encoding import DVSEncoder",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 176
  },
  {
    "area": "edge_features",
    "text": "# or for CSI camera on Jetson:",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 180
  },
  {
    "area": "performance",
    "text": "# cap = cv2.VideoCapture(\"nvarguscamerasrc ! video/x-raw(memory:NVMM), width=640, height=480, format=(string)NV12, framerate=(fraction)30/1 ! nvvidconv ! video/x-raw, format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 181
  },
  {
    "area": "sensory_encoding",
    "text": "# Create DVS encoder",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 183
  },
  {
    "area": "sensory_encoding",
    "text": "encoder = DVSEncoder(resolution=(64, 64), threshold=0.1)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 184
  },
  {
    "area": "edge_features",
    "text": "api = NeuromorphicAPI(device=\"jetson\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 187
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 188
  },
  {
    "area": "neuron_models",
    "text": "api.add_sensory_layer(\"retina\", 64*64, \"lif\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 189
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"v1\", 256, \"lif\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 190
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"detection\", 10)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 191
  },
  {
    "area": "performance",
    "text": "# Real-time processing loop",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 193
  },
  {
    "area": "sensory_encoding",
    "text": "events = encoder.encode_difference(prev_frame, resized)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 206
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 210
  },
  {
    "area": "edge_features",
    "text": "api = NeuromorphicAPI(device=\"jetson\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 244
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 245
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"imu\", 6, \"rate\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 246
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"integration\", 20, \"adex\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 247
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"balance\", 4)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 248
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 261
  },
  {
    "area": "edge_features",
    "text": "## Power Management",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 273
  },
  {
    "area": "edge_features",
    "text": "### Dynamic Power Scaling",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 275
  },
  {
    "area": "edge_features",
    "text": "from scripts.jetson_optimization import PowerManager",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 280
  },
  {
    "area": "edge_features",
    "text": "# Initialize power manager",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 282
  },
  {
    "area": "edge_features",
    "text": "pm = PowerManager()",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 283
  },
  {
    "area": "edge_features",
    "text": "# Low power mode",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 289
  },
  {
    "area": "edge_features",
    "text": "pm.set_power_mode(\"5W\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 290
  },
  {
    "area": "simulation_modes",
    "text": "api.set_simulation_quality(\"low\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 291
  },
  {
    "area": "neuron_models",
    "text": "elif battery_level < 50:",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 292
  },
  {
    "area": "edge_features",
    "text": "pm.set_power_mode(\"10W\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 294
  },
  {
    "area": "simulation_modes",
    "text": "api.set_simulation_quality(\"medium\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 295
  },
  {
    "area": "edge_features",
    "text": "pm.set_power_mode(\"MAXN\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 298
  },
  {
    "area": "simulation_modes",
    "text": "api.set_simulation_quality(\"high\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 299
  },
  {
    "area": "edge_features",
    "text": "Implement power-saving sleep cycles:",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 309
  },
  {
    "area": "api_docs",
    "text": "api.set_sleep_mode(",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 313
  },
  {
    "area": "api_docs",
    "text": "if api.has_input():",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 321
  },
  {
    "area": "api_docs",
    "text": "api.wake()",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 323
  },
  {
    "area": "api_docs",
    "text": "results = api.process_input()",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 324
  },
  {
    "area": "api_docs",
    "text": "if api.is_idle():",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 327
  },
  {
    "area": "api_docs",
    "text": "api.sleep()",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 328
  },
  {
    "area": "edge_features",
    "text": "## Deployment Examples",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 333
  },
  {
    "area": "edge_features",
    "text": "api = NeuromorphicAPI(device=\"jetson\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 341
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 342
  },
  {
    "area": "neuron_models",
    "text": "api.add_sensory_layer(\"vision\", 1024, \"lif\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 345
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"lidar\", 360, \"rate\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 346
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"imu\", 9, \"rate\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 347
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"perception\", 256, \"adex\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 350
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"planning\", 128, \"adex\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 351
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"wheels\", 2)  # Left, right",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 354
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"arm\", 6)     # 6-DOF arm",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 355
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"vision\", \"perception\", \"feedforward\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 358
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"lidar\", \"perception\", \"feedforward\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 359
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"imu\", \"planning\", \"feedforward\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 360
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"perception\", \"planning\", \"feedforward\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 361
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"planning\", \"wheels\", \"feedforward\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 362
  },
  {
    "area": "api_docs",
    "text": "api.connect_layers(\"planning\", \"arm\", \"feedforward\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 363
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(20.0, external_inputs=inputs)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 379
  },
  {
    "area": "edge_features",
    "text": "api = NeuromorphicAPI(device=\"jetson\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 395
  },
  {
    "area": "api_docs",
    "text": "api.create_network()",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 396
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"temperature\", 10, \"rate\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 399
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"humidity\", 10, \"rate\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 400
  },
  {
    "area": "api_docs",
    "text": "api.add_sensory_layer(\"motion\", 100, \"temporal\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 401
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"feature\", 50, \"lif\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 404
  },
  {
    "area": "neuron_models",
    "text": "api.add_processing_layer(\"anomaly\", 20, \"adex\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 405
  },
  {
    "area": "api_docs",
    "text": "api.add_motor_layer(\"alert\", 3)  # Normal, warning, critical",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 406
  },
  {
    "area": "api_docs",
    "text": "train_anomaly_detector(api, normal_data)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 409
  },
  {
    "area": "edge_features",
    "text": "# Deployment",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 411
  },
  {
    "area": "simulation_modes",
    "text": "results = api.run_simulation(50.0, external_inputs=inputs)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 425
  },
  {
    "area": "edge_features",
    "text": "# Power-efficient sleep",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 433
  },
  {
    "area": "edge_features",
    "text": "### Jetson Nano Performance",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 439
  },
  {
    "area": "edge_features",
    "text": "| Metric | Desktop | Jetson Nano | Optimization |",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 441
  },
  {
    "area": "simulation_modes",
    "text": "| Simulation Speed | 1000x real-time | 100x real-time | 10x slower |",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 445
  },
  {
    "area": "edge_features",
    "text": "| Power Usage | 50-100W | 5-10W | 90% reduction |",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 446
  },
  {
    "area": "performance",
    "text": "| Memory | 4-8GB | 2-4GB | 50% reduction |",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 447
  },
  {
    "area": "edge_features",
    "text": "from benchmarks.edge_benchmarks import benchmark_edge",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 453
  },
  {
    "area": "edge_features",
    "text": "results = benchmark_edge(config)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 464
  },
  {
    "area": "performance",
    "text": "print(f\"  Speed: {results['speed']} Hz\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 466
  },
  {
    "area": "edge_features",
    "text": "print(f\"  Power: {results['power']} W\")",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 467
  },
  {
    "area": "performance",
    "text": "1. **Out of Memory**",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 475
  },
  {
    "area": "simulation_modes",
    "text": "- Use event-driven mode",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 482
  },
  {
    "area": "edge_features",
    "text": "3. **High Power Usage**",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 485
  },
  {
    "area": "edge_features",
    "text": "- Use appropriate power mode",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 486
  },
  {
    "area": "performance",
    "text": "- Reduce clock speeds",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 492
  },
  {
    "area": "edge_features",
    "text": "- Read [Deployment Best Practices](08_deployment_best_practices.md)",
    "file": "docs\\tutorials\\05_edge_deployment.md",
    "line": 499
  },
  {
    "area": "edge_features",
    "text": "# Jetson Nano Neuromorphic System Deployment Guide",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 1
  },
  {
    "area": "edge_features",
    "text": "This guide provides step-by-step instructions for deploying the neuromorphic programming system on NVIDIA Jetson Nano 8GB for edge neuromorphic computing applications.",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 3
  },
  {
    "area": "edge_features",
    "text": "- **NVIDIA Jetson Nano 8GB** (B01 or B02)",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 8
  },
  {
    "area": "edge_features",
    "text": "- **Power Supply**: 5V/4A barrel jack power supply",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 10
  },
  {
    "area": "edge_features",
    "text": "### 1. Initial Jetson Setup",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 21
  },
  {
    "area": "edge_features",
    "text": "# Follow NVIDIA's official guide: https://developer.nvidia.com/embedded/learn/get-started-jetson-nano-devkit",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 25
  },
  {
    "area": "edge_features",
    "text": "# Boot Jetson Nano and complete initial setup",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 27
  },
  {
    "area": "visualization_monitoring",
    "text": "# Install system monitoring tools",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 42
  },
  {
    "area": "edge_features",
    "text": "sudo jetson_clocks  # Enable maximum performance",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 48
  },
  {
    "area": "visualization_monitoring",
    "text": "pip3 install numpy scipy scikit-learn pandas matplotlib seaborn psutil",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 60
  },
  {
    "area": "performance",
    "text": "python3 -c \"import cupy as cp; print('GPU memory:', cp.cuda.runtime.memGetInfo())\"",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 71
  },
  {
    "area": "edge_features",
    "text": "# Install OpenCV for Jetson",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 73
  },
  {
    "area": "edge_features",
    "text": "# Clone or copy the neuromorphic system to Jetson",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 80
  },
  {
    "area": "edge_features",
    "text": "pip3 install -r requirements_jetson.txt",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 86
  },
  {
    "area": "edge_features",
    "text": "python3 -c \"from jetson_optimization import JetsonOptimizer; print('Installation successful')\"",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 89
  },
  {
    "area": "edge_features",
    "text": "Create `/home/nano/neuron/jetson_config.py`:",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 96
  },
  {
    "area": "edge_features",
    "text": "# Jetson-specific configuration",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 99
  },
  {
    "area": "edge_features",
    "text": "JETSON_CONFIG = {",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 100
  },
  {
    "area": "edge_features",
    "text": "'max_neurons': 1000,        # Maximum neurons for Jetson",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 101
  },
  {
    "area": "edge_features",
    "text": "'max_synapses': 10000,      # Maximum synapses for Jetson",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 102
  },
  {
    "area": "edge_features",
    "text": "'power_limit': 10,          # Power limit (W)",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 105
  },
  {
    "area": "edge_features",
    "text": "'connection_probability': 0.05,  # Reduced for Jetson",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 109
  },
  {
    "area": "visualization_monitoring",
    "text": "# Performance monitoring",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 112
  },
  {
    "area": "visualization_monitoring",
    "text": "'monitor_interval': 1.0,    # Monitoring interval (seconds)",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 113
  },
  {
    "area": "edge_features",
    "text": "cat > /home/nano/tune_jetson.sh << 'EOF'",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 122
  },
  {
    "area": "edge_features",
    "text": "sudo jetson_clocks",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 130
  },
  {
    "area": "performance",
    "text": "# Optimize memory",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 132
  },
  {
    "area": "edge_features",
    "text": "echo \"Jetson Nano optimized for neuromorphic computing\"",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 138
  },
  {
    "area": "edge_features",
    "text": "chmod +x /home/nano/tune_jetson.sh",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 141
  },
  {
    "area": "edge_features",
    "text": "from jetson_optimization import JetsonSensorimotorSystem",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 149
  },
  {
    "area": "edge_features",
    "text": "system = JetsonSensorimotorSystem(use_gpu=True)",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 153
  },
  {
    "area": "performance",
    "text": "### 2. Real-time Monitoring",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 167
  },
  {
    "area": "edge_features",
    "text": "from jetson_optimization import JetsonOptimizer",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 170
  },
  {
    "area": "edge_features",
    "text": "optimizer = JetsonOptimizer()",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 173
  },
  {
    "area": "performance",
    "text": "print(f\"Memory: {system_info['memory_available'] / (1024**3):.2f} GB available\")",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 178
  },
  {
    "area": "edge_features",
    "text": "print(f\"Power: {system_info['power_consumption']:.2f}W\")",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 180
  },
  {
    "area": "edge_features",
    "text": "### 3. Learning on Jetson",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 184
  },
  {
    "area": "edge_features",
    "text": "from demo.jetson_demo import demonstrate_jetson_learning",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 187
  },
  {
    "area": "edge_features",
    "text": "learning_results = demonstrate_jetson_learning()",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 190
  },
  {
    "area": "performance",
    "text": "### 1. Memory Management",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 196
  },
  {
    "area": "performance",
    "text": "# Monitor memory usage",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 199
  },
  {
    "area": "performance",
    "text": "def optimize_memory():",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 203
  },
  {
    "area": "edge_features",
    "text": "\"\"\"Optimize memory usage for Jetson.\"\"\"",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 204
  },
  {
    "area": "performance",
    "text": "# Get memory info",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 208
  },
  {
    "area": "performance",
    "text": "memory = psutil.virtual_memory()",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 209
  },
  {
    "area": "performance",
    "text": "print(f\"Memory usage: {memory.percent}%\")",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 210
  },
  {
    "area": "performance",
    "text": "# Reduce network size if memory usage is high",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 212
  },
  {
    "area": "performance",
    "text": "if memory.percent > 80:",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 213
  },
  {
    "area": "performance",
    "text": "print(\"Warning: High memory usage detected\")",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 214
  },
  {
    "area": "edge_features",
    "text": "### 3. Power Optimization",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 237
  },
  {
    "area": "edge_features",
    "text": "def optimize_power():",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 240
  },
  {
    "area": "edge_features",
    "text": "\"\"\"Optimize power consumption.\"\"\"",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 241
  },
  {
    "area": "performance",
    "text": "os.system(\"echo 1479000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed\")",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 243
  },
  {
    "area": "performance",
    "text": "2. **Memory Issues**",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 263
  },
  {
    "area": "performance",
    "text": "# Check memory usage",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 265
  },
  {
    "area": "visualization_monitoring",
    "text": "### Performance Monitoring",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 282
  },
  {
    "area": "edge_features",
    "text": "# Monitor system resources",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 285
  },
  {
    "area": "edge_features",
    "text": "## Deployment Checklist",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 295
  },
  {
    "area": "edge_features",
    "text": "- [ ] Jetson Nano properly flashed with JetPack",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 297
  },
  {
    "area": "visualization_monitoring",
    "text": "- [ ] Performance monitoring configured",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 302
  },
  {
    "area": "edge_features",
    "text": "- [ ] Temperature and power limits set",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 303
  },
  {
    "area": "edge_features",
    "text": "### Jetson Nano 8GB Performance Metrics",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 310
  },
  {
    "area": "performance",
    "text": "| **Memory Usage** | 2-4GB | For typical networks |",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 316
  },
  {
    "area": "edge_features",
    "text": "| **Power Consumption** | 5-10W | Depending on mode |",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 318
  },
  {
    "area": "edge_features",
    "text": "| **Network Size** | 500-2000 neurons | Optimized for Jetson |",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 319
  },
  {
    "area": "edge_features",
    "text": "3. **Optimize network size** for Jetson constraints",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 326
  },
  {
    "area": "edge_features",
    "text": "5. **Implement proper error handling** for edge deployment",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 328
  },
  {
    "area": "performance",
    "text": "### 1. Real-time Sensor Integration",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 333
  },
  {
    "area": "edge_features",
    "text": "# Resize for Jetson optimization",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 343
  },
  {
    "area": "edge_features",
    "text": "# Audio processing for Jetson",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 352
  },
  {
    "area": "performance",
    "text": "# Implement real-time audio processing",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 357
  },
  {
    "area": "edge_features",
    "text": "# Optimize for Jetson's audio capabilities",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 358
  },
  {
    "area": "edge_features",
    "text": "# Dynamic network sizing based on Jetson performance",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 365
  },
  {
    "area": "edge_features",
    "text": "system_info = JetsonOptimizer().get_system_info()",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 367
  },
  {
    "area": "neuron_models",
    "text": "elif system_info['memory_available'] < 2 * (1024**3):",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 371
  },
  {
    "area": "edge_features",
    "text": "The neuromorphic programming system is now optimized for deployment on NVIDIA Jetson Nano 8GB. The system provides:",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 379
  },
  {
    "area": "performance",
    "text": "- **Real-time inference** capabilities",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 381
  },
  {
    "area": "edge_features",
    "text": "- **Adaptive learning** on edge devices",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 382
  },
  {
    "area": "visualization_monitoring",
    "text": "- **Performance monitoring** and optimization",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 383
  },
  {
    "area": "edge_features",
    "text": "- **Temperature and power management**",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 384
  },
  {
    "area": "edge_features",
    "text": "This deployment enables edge neuromorphic computing applications with biological plausibility and real-world performance constraints.",
    "file": "JETSON_DEPLOYMENT.md",
    "line": 387
  },
  {
    "area": "performance",
    "text": "![Throughput](https://img.shields.io/badge/Throughput-50K_neurons/sec-green)",
    "file": "docs\\benchmarks.md",
    "line": 7
  },
  {
    "area": "performance",
    "text": "![Memory](https://img.shields.io/badge/Memory-53MB-brightgreen)",
    "file": "docs\\benchmarks.md",
    "line": 8
  },
  {
    "area": "performance",
    "text": "### Step Throughput (neurons/sec)",
    "file": "docs\\benchmarks.md",
    "line": 13
  },
  {
    "area": "performance",
    "text": "| Network Size | Throughput (neurons/sec) | Performance |",
    "file": "docs\\benchmarks.md",
    "line": 15
  },
  {
    "area": "performance",
    "text": "### Memory Footprint",
    "file": "docs\\benchmarks.md",
    "line": 22
  },
  {
    "area": "performance",
    "text": "| Network Size | Memory Usage (MB) | Memory/Neuron (KB) |",
    "file": "docs\\benchmarks.md",
    "line": 24
  },
  {
    "area": "performance",
    "text": "### Convergence Speed",
    "file": "docs\\benchmarks.md",
    "line": 31
  },
  {
    "area": "neuromodulation",
    "text": "| Homeostatic Adaptation | Adaptation Speed | 0.0150 | Good |",
    "file": "docs\\benchmarks.md",
    "line": 37
  },
  {
    "area": "performance",
    "text": "Total Memory: 15.9 GB",
    "file": "docs\\benchmarks.md",
    "line": 46
  },
  {
    "area": "performance",
    "text": "- **Throughput Optimization**: Consider implementing vectorized operations",
    "file": "docs\\benchmarks.md",
    "line": 53
  },
  {
    "area": "performance",
    "text": "- **Memory Efficiency**: Current memory usage is acceptable",
    "file": "docs\\benchmarks.md",
    "line": 54
  },
  {
    "area": "performance",
    "text": "### 1. Step Throughput",
    "file": "docs\\benchmarks.md",
    "line": 77
  },
  {
    "area": "simulation_modes",
    "text": "- Full network simulation speed",
    "file": "docs\\benchmarks.md",
    "line": 81
  },
  {
    "area": "performance",
    "text": "### 2. Memory Footprint",
    "file": "docs\\benchmarks.md",
    "line": 83
  },
  {
    "area": "performance",
    "text": "Tracks memory usage across different scales:",
    "file": "docs\\benchmarks.md",
    "line": 84
  },
  {
    "area": "performance",
    "text": "- Per-neuron memory overhead",
    "file": "docs\\benchmarks.md",
    "line": 85
  },
  {
    "area": "performance",
    "text": "### 3. Convergence Speed",
    "file": "docs\\benchmarks.md",
    "line": 89
  },
  {
    "area": "performance",
    "text": "Evaluates learning efficiency on standard tasks:",
    "file": "docs\\benchmarks.md",
    "line": 90
  },
  {
    "area": "neuromodulation",
    "text": "- Homeostatic adaptation speed",
    "file": "docs\\benchmarks.md",
    "line": 93
  },
  {
    "area": "simulation_modes",
    "text": "- Simulation stepping with various configurations",
    "file": "docs\\benchmarks.md",
    "line": 106
  },
  {
    "area": "performance",
    "text": "| Throughput (1K network) | 25K neurons/sec | 50K neurons/sec | In Progress |",
    "file": "docs\\benchmarks.md",
    "line": 113
  },
  {
    "area": "performance",
    "text": "| Memory (1K network) | 15.2 MB | < 10 MB | Optimizing |",
    "file": "docs\\benchmarks.md",
    "line": 114
  },
  {
    "area": "performance",
    "text": "| Real-time Factor | 0.5x | > 1.0x | In Progress |",
    "file": "docs\\benchmarks.md",
    "line": 116
  },
  {
    "area": "simulation_modes",
    "text": "# Neuromorphic Simulation System - Production Architecture",
    "file": "ARCHITECTURE.md",
    "line": 1
  },
  {
    "area": "simulation_modes",
    "text": "This document defines the production-ready architecture for the neuromorphic simulation system following a comprehensive repository audit and restructuring. The system has been reorganized from a proof-of-concept structure into a maintainable, scalable production codebase suitable for deployment, testing, and continuous development.",
    "file": "ARCHITECTURE.md",
    "line": 5
  },
  {
    "area": "simulation_modes",
    "text": "- **Core simulation components** (`core/` directory):",
    "file": "ARCHITECTURE.md",
    "line": 19
  },
  {
    "area": "neuron_models",
    "text": "- `neurons.py` - Neuron models (AdEx, Hodgkin-Huxley, LIF)",
    "file": "ARCHITECTURE.md",
    "line": 20
  },
  {
    "area": "plasticity",
    "text": "- `synapses.py` - Synapse models and plasticity rules",
    "file": "ARCHITECTURE.md",
    "line": 21
  },
  {
    "area": "simulation_modes",
    "text": "- `network.py` - Network architecture and simulation engine",
    "file": "ARCHITECTURE.md",
    "line": 22
  },
  {
    "area": "neuromodulation",
    "text": "- `neuromodulation.py` - Neuromodulatory systems",
    "file": "ARCHITECTURE.md",
    "line": 24
  },
  {
    "area": "api_docs",
    "text": "- **API layer** (`api/` directory):",
    "file": "ARCHITECTURE.md",
    "line": 26
  },
  {
    "area": "api_docs",
    "text": "- `neuromorphic_api.py` - High-level programming interface",
    "file": "ARCHITECTURE.md",
    "line": 27
  },
  {
    "area": "edge_features",
    "text": "- Jetson deployment examples",
    "file": "ARCHITECTURE.md",
    "line": 33
  },
  {
    "area": "visualization_monitoring",
    "text": "- `enhanced_plots/`",
    "file": "ARCHITECTURE.md",
    "line": 52
  },
  {
    "area": "api_docs",
    "text": "- Development documentation archived to `archive/reports/`",
    "file": "ARCHITECTURE.md",
    "line": 71
  },
  {
    "area": "visualization_monitoring",
    "text": "- `enhanced_plots/` (empty)",
    "file": "ARCHITECTURE.md",
    "line": 83
  },
  {
    "area": "simulation_modes",
    "text": "\u2502   \u2514\u2500\u2500 neuron_sim/              # Core simulation package",
    "file": "ARCHITECTURE.md",
    "line": 99
  },
  {
    "area": "neuron_models",
    "text": "\u2502       \u2502   \u251c\u2500\u2500 neurons.py      # Neuron models",
    "file": "ARCHITECTURE.md",
    "line": 104
  },
  {
    "area": "simulation_modes",
    "text": "\u2502       \u2502   \u2514\u2500\u2500 simulation.py   # Simulation engine",
    "file": "ARCHITECTURE.md",
    "line": 109
  },
  {
    "area": "neuron_models",
    "text": "\u2502       \u2502   \u251c\u2500\u2500 adex.py         # AdEx neuron",
    "file": "ARCHITECTURE.md",
    "line": 112
  },
  {
    "area": "neuron_models",
    "text": "\u2502       \u2502   \u251c\u2500\u2500 hodgkin_huxley.py",
    "file": "ARCHITECTURE.md",
    "line": 113
  },
  {
    "area": "neuron_models",
    "text": "\u2502       \u2502   \u251c\u2500\u2500 lif.py          # Leaky Integrate-and-Fire",
    "file": "ARCHITECTURE.md",
    "line": 114
  },
  {
    "area": "plasticity",
    "text": "\u2502       \u2502   \u2514\u2500\u2500 plasticity.py   # Plasticity rules",
    "file": "ARCHITECTURE.md",
    "line": 115
  },
  {
    "area": "plasticity",
    "text": "\u2502       \u2502   \u251c\u2500\u2500 stdp.py         # STDP implementation",
    "file": "ARCHITECTURE.md",
    "line": 118
  },
  {
    "area": "plasticity",
    "text": "\u2502       \u2502   \u251c\u2500\u2500 rstdp.py        # Reward-modulated STDP",
    "file": "ARCHITECTURE.md",
    "line": 119
  },
  {
    "area": "plasticity",
    "text": "\u2502       \u2502   \u2514\u2500\u2500 hebbian.py      # Hebbian learning",
    "file": "ARCHITECTURE.md",
    "line": 120
  },
  {
    "area": "api_docs",
    "text": "\u2502       \u251c\u2500\u2500 api/                 # High-level API",
    "file": "ARCHITECTURE.md",
    "line": 126
  },
  {
    "area": "simulation_modes",
    "text": "\u2502       \u2502   \u251c\u2500\u2500 simulator.py    # Simulation interface",
    "file": "ARCHITECTURE.md",
    "line": 129
  },
  {
    "area": "edge_features",
    "text": "\u2502       \u2502   \u251c\u2500\u2500 jetson.py       # Jetson optimization",
    "file": "ARCHITECTURE.md",
    "line": 134
  },
  {
    "area": "performance",
    "text": "\u2502       \u2502   \u2514\u2500\u2500 memory.py       # Memory management",
    "file": "ARCHITECTURE.md",
    "line": 135
  },
  {
    "area": "plasticity",
    "text": "\u2502   \u2502   \u2514\u2500\u2500 test_plasticity.py",
    "file": "ARCHITECTURE.md",
    "line": 149
  },
  {
    "area": "performance",
    "text": "\u2502       \u251c\u2500\u2500 test_scalability.py",
    "file": "ARCHITECTURE.md",
    "line": 155
  },
  {
    "area": "performance",
    "text": "\u2502       \u2514\u2500\u2500 test_memory.py",
    "file": "ARCHITECTURE.md",
    "line": 156
  },
  {
    "area": "api_docs",
    "text": "\u251c\u2500\u2500 docs/                        # Documentation",
    "file": "ARCHITECTURE.md",
    "line": 157
  },
  {
    "area": "api_docs",
    "text": "\u2502   \u2502   \u251c\u2500\u2500 api/                # API documentation",
    "file": "ARCHITECTURE.md",
    "line": 161
  },
  {
    "area": "api_docs",
    "text": "\u2502   \u2502   \u251c\u2500\u2500 tutorials/          # User tutorials",
    "file": "ARCHITECTURE.md",
    "line": 162
  },
  {
    "area": "api_docs",
    "text": "\u2502   \u251c\u2500\u2500 build/                  # Built documentation",
    "file": "ARCHITECTURE.md",
    "line": 164
  },
  {
    "area": "api_docs",
    "text": "\u2502   \u2514\u2500\u2500 README.md               # Documentation guide",
    "file": "ARCHITECTURE.md",
    "line": 165
  },
  {
    "area": "plasticity",
    "text": "\u2502   \u2502   \u251c\u2500\u2500 stdp_learning.py",
    "file": "ARCHITECTURE.md",
    "line": 173
  },
  {
    "area": "neuromodulation",
    "text": "\u2502   \u2502   \u251c\u2500\u2500 reward_learning.py",
    "file": "ARCHITECTURE.md",
    "line": 174
  },
  {
    "area": "performance",
    "text": "\u2502   \u251c\u2500\u2500 memory/                  # Memory demonstrations",
    "file": "ARCHITECTURE.md",
    "line": 176
  },
  {
    "area": "performance",
    "text": "\u2502   \u2502   \u251c\u2500\u2500 working_memory.py",
    "file": "ARCHITECTURE.md",
    "line": 177
  },
  {
    "area": "performance",
    "text": "\u2502   \u2502   \u251c\u2500\u2500 associative_memory.py",
    "file": "ARCHITECTURE.md",
    "line": 178
  },
  {
    "area": "edge_features",
    "text": "\u2502   \u2502   \u251c\u2500\u2500 cd.yml              # Continuous Deployment",
    "file": "ARCHITECTURE.md",
    "line": 196
  },
  {
    "area": "api_docs",
    "text": "\u2502   \u2502   \u2514\u2500\u2500 docs.yml            # Documentation build",
    "file": "ARCHITECTURE.md",
    "line": 198
  },
  {
    "area": "edge_features",
    "text": "\u2502   \u2502   \u2514\u2500\u2500 setup_jetson.sh",
    "file": "ARCHITECTURE.md",
    "line": 205
  },
  {
    "area": "edge_features",
    "text": "\u2502   \u2514\u2500\u2500 deployment/             # Deployment tools",
    "file": "ARCHITECTURE.md",
    "line": 210
  },
  {
    "area": "api_docs",
    "text": "\u2502   \u2514\u2500\u2500 README.md              # Archive documentation",
    "file": "ARCHITECTURE.md",
    "line": 217
  },
  {
    "area": "edge_features",
    "text": "\u2502   \u251c\u2500\u2500 jetson.txt             # Jetson dependencies",
    "file": "ARCHITECTURE.md",
    "line": 225
  },
  {
    "area": "api_docs",
    "text": "\u2502   \u2514\u2500\u2500 docs.txt               # Documentation dependencies",
    "file": "ARCHITECTURE.md",
    "line": 226
  },
  {
    "area": "simulation_modes",
    "text": "### 1. Core Simulation Package (`src/neuron_sim/`)",
    "file": "ARCHITECTURE.md",
    "line": 243
  },
  {
    "area": "simulation_modes",
    "text": "- **Purpose**: Fundamental simulation components",
    "file": "ARCHITECTURE.md",
    "line": 248
  },
  {
    "area": "neuron_models",
    "text": "- Neuron model implementations",
    "file": "ARCHITECTURE.md",
    "line": 250
  },
  {
    "area": "plasticity",
    "text": "- Synapse and plasticity mechanisms",
    "file": "ARCHITECTURE.md",
    "line": 251
  },
  {
    "area": "simulation_modes",
    "text": "- Simulation engine coordination",
    "file": "ARCHITECTURE.md",
    "line": 253
  },
  {
    "area": "neuron_models",
    "text": "- Biologically accurate neuron models",
    "file": "ARCHITECTURE.md",
    "line": 258
  },
  {
    "area": "plasticity",
    "text": "- Various plasticity rules",
    "file": "ARCHITECTURE.md",
    "line": 259
  },
  {
    "area": "plasticity",
    "text": "- STDP and variants",
    "file": "ARCHITECTURE.md",
    "line": 265
  },
  {
    "area": "api_docs",
    "text": "#### API (`api/`)",
    "file": "ARCHITECTURE.md",
    "line": 276
  },
  {
    "area": "neuron_models",
    "text": "- Simplified network construction",
    "file": "ARCHITECTURE.md",
    "line": 279
  },
  {
    "area": "simulation_modes",
    "text": "- Simulation management",
    "file": "ARCHITECTURE.md",
    "line": 280
  },
  {
    "area": "visualization_monitoring",
    "text": "- Result analysis and visualization",
    "file": "ARCHITECTURE.md",
    "line": 281
  },
  {
    "area": "edge_features",
    "text": "- Jetson Nano optimization",
    "file": "ARCHITECTURE.md",
    "line": 287
  },
  {
    "area": "performance",
    "text": "- Memory management strategies",
    "file": "ARCHITECTURE.md",
    "line": 288
  },
  {
    "area": "performance",
    "text": "- Scalability testing",
    "file": "ARCHITECTURE.md",
    "line": 307
  },
  {
    "area": "performance",
    "text": "- Memory profiling",
    "file": "ARCHITECTURE.md",
    "line": 308
  },
  {
    "area": "edge_features",
    "text": "- Resource usage monitoring",
    "file": "ARCHITECTURE.md",
    "line": 310
  },
  {
    "area": "api_docs",
    "text": "### 3. Documentation (`docs/`)",
    "file": "ARCHITECTURE.md",
    "line": 312
  },
  {
    "area": "api_docs",
    "text": "Comprehensive documentation using Sphinx:",
    "file": "ARCHITECTURE.md",
    "line": 314
  },
  {
    "area": "api_docs",
    "text": "#### API Documentation",
    "file": "ARCHITECTURE.md",
    "line": 316
  },
  {
    "area": "api_docs",
    "text": "- Cross-references",
    "file": "ARCHITECTURE.md",
    "line": 319
  },
  {
    "area": "api_docs",
    "text": "#### Tutorials",
    "file": "ARCHITECTURE.md",
    "line": 321
  },
  {
    "area": "plasticity",
    "text": "- STDP in action",
    "file": "ARCHITECTURE.md",
    "line": 341
  },
  {
    "area": "performance",
    "text": "- Memory formation",
    "file": "ARCHITECTURE.md",
    "line": 343
  },
  {
    "area": "visualization_monitoring",
    "text": "Performance monitoring:",
    "file": "ARCHITECTURE.md",
    "line": 352
  },
  {
    "area": "neuron_models",
    "text": "- Neuron model performance",
    "file": "ARCHITECTURE.md",
    "line": 355
  },
  {
    "area": "performance",
    "text": "- Network scalability",
    "file": "ARCHITECTURE.md",
    "line": 356
  },
  {
    "area": "performance",
    "text": "- Memory usage patterns",
    "file": "ARCHITECTURE.md",
    "line": 361
  },
  {
    "area": "edge_features",
    "text": "#### Continuous Deployment",
    "file": "ARCHITECTURE.md",
    "line": 373
  },
  {
    "area": "edge_features",
    "text": "- Documentation deployment",
    "file": "ARCHITECTURE.md",
    "line": 375
  },
  {
    "area": "visualization_monitoring",
    "text": "- Network visualization",
    "file": "ARCHITECTURE.md",
    "line": 388
  },
  {
    "area": "edge_features",
    "text": "#### Deployment Tools",
    "file": "ARCHITECTURE.md",
    "line": 392
  },
  {
    "area": "edge_features",
    "text": "- Cloud deployment",
    "file": "ARCHITECTURE.md",
    "line": 395
  },
  {
    "area": "plasticity",
    "text": "E --> F[Synaptic Plasticity]",
    "file": "ARCHITECTURE.md",
    "line": 405
  },
  {
    "area": "neuromodulation",
    "text": "J[Reward Signals] --> I",
    "file": "ARCHITECTURE.md",
    "line": 410
  },
  {
    "area": "visualization_monitoring",
    "text": "L[Monitoring] --> M[Metrics]",
    "file": "ARCHITECTURE.md",
    "line": 413
  },
  {
    "area": "visualization_monitoring",
    "text": "M --> N[Visualization]",
    "file": "ARCHITECTURE.md",
    "line": 414
  },
  {
    "area": "visualization_monitoring",
    "text": "- **Visualization**: Matplotlib, Plotly",
    "file": "ARCHITECTURE.md",
    "line": 426
  },
  {
    "area": "api_docs",
    "text": "- **Documentation**: Sphinx, MkDocs",
    "file": "ARCHITECTURE.md",
    "line": 428
  },
  {
    "area": "edge_features",
    "text": "### Edge Deployment",
    "file": "ARCHITECTURE.md",
    "line": 435
  },
  {
    "area": "edge_features",
    "text": "- **Jetson**: NVIDIA Jetson Nano/Xavier",
    "file": "ARCHITECTURE.md",
    "line": 436
  },
  {
    "area": "api_docs",
    "text": "### Phase 4: Documentation (Week 4)",
    "file": "ARCHITECTURE.md",
    "line": 469
  },
  {
    "area": "api_docs",
    "text": "1. Set up Sphinx documentation",
    "file": "ARCHITECTURE.md",
    "line": 470
  },
  {
    "area": "api_docs",
    "text": "2. Write API documentation",
    "file": "ARCHITECTURE.md",
    "line": 471
  },
  {
    "area": "api_docs",
    "text": "3. Create user tutorials",
    "file": "ARCHITECTURE.md",
    "line": 472
  },
  {
    "area": "api_docs",
    "text": "5. Deploy documentation site",
    "file": "ARCHITECTURE.md",
    "line": 474
  },
  {
    "area": "api_docs",
    "text": "3. Configure documentation builds",
    "file": "ARCHITECTURE.md",
    "line": 479
  },
  {
    "area": "edge_features",
    "text": "5. Set up deployment automation",
    "file": "ARCHITECTURE.md",
    "line": 481
  },
  {
    "area": "api_docs",
    "text": "- **Documentation**: Comprehensive docstrings",
    "file": "ARCHITECTURE.md",
    "line": 488
  },
  {
    "area": "simulation_modes",
    "text": "- **Simulation Speed**: 1000x real-time (desktop)",
    "file": "ARCHITECTURE.md",
    "line": 493
  },
  {
    "area": "performance",
    "text": "- **Memory Efficiency**: <1KB per neuron",
    "file": "ARCHITECTURE.md",
    "line": 494
  },
  {
    "area": "performance",
    "text": "- **Scalability**: 10,000+ neurons",
    "file": "ARCHITECTURE.md",
    "line": 495
  },
  {
    "area": "api_docs",
    "text": "### Documentation Standards",
    "file": "ARCHITECTURE.md",
    "line": 498
  },
  {
    "area": "api_docs",
    "text": "- **API Docs**: 100% coverage",
    "file": "ARCHITECTURE.md",
    "line": 499
  },
  {
    "area": "api_docs",
    "text": "- **Tutorials**: Step-by-step guides",
    "file": "ARCHITECTURE.md",
    "line": 501
  },
  {
    "area": "edge_features",
    "text": "### Resource Management",
    "file": "ARCHITECTURE.md",
    "line": 511
  },
  {
    "area": "performance",
    "text": "- Memory limits enforcement",
    "file": "ARCHITECTURE.md",
    "line": 512
  },
  {
    "area": "visualization_monitoring",
    "text": "- Disk space monitoring",
    "file": "ARCHITECTURE.md",
    "line": 514
  },
  {
    "area": "api_docs",
    "text": "- API authentication",
    "file": "ARCHITECTURE.md",
    "line": 517
  },
  {
    "area": "api_docs",
    "text": "- **Documentation**: Required for API changes",
    "file": "ARCHITECTURE.md",
    "line": 532
  },
  {
    "area": "edge_features",
    "text": "3. **Q3 2025**: Cloud deployment",
    "file": "ARCHITECTURE.md",
    "line": 538
  },
  {
    "area": "visualization_monitoring",
    "text": "## Monitoring and Observability",
    "file": "ARCHITECTURE.md",
    "line": 541
  },
  {
    "area": "edge_features",
    "text": "- Resource utilization",
    "file": "ARCHITECTURE.md",
    "line": 545
  },
  {
    "area": "edge_features",
    "text": "- Resource exhaustion",
    "file": "ARCHITECTURE.md",
    "line": 558
  },
  {
    "area": "edge_features",
    "text": "## Deployment Architecture",
    "file": "ARCHITECTURE.md",
    "line": 561
  },
  {
    "area": "simulation_modes",
    "text": "This architecture provides a solid foundation for a production-ready neuromorphic simulation system. The modular design ensures maintainability, the comprehensive testing ensures reliability, and the optimization strategies ensure performance. The system is designed to scale from research prototypes to production deployments while maintaining biological plausibility and computational efficiency.",
    "file": "ARCHITECTURE.md",
    "line": 583
  },
  {
    "area": "api_docs",
    "text": "| `api/*.py` | `src/neuron_sim/api/` | Move |",
    "file": "ARCHITECTURE.md",
    "line": 590
  },
  {
    "area": "visualization_monitoring",
    "text": "matplotlib>=3.4.0",
    "file": "ARCHITECTURE.md",
    "line": 606
  },
  {
    "area": "edge_features",
    "text": "### Jetson Dependencies (`requirements/jetson.txt`)",
    "file": "ARCHITECTURE.md",
    "line": 626
  },
  {
    "area": "edge_features",
    "text": "# Jetson-specific optimizations",
    "file": "ARCHITECTURE.md",
    "line": 628
  },
  {
    "area": "api_docs",
    "text": "docs:          # Build documentation",
    "file": "ARCHITECTURE.md",
    "line": 639
  },
  {
    "area": "simulation_modes",
    "text": "*This architecture document serves as the blueprint for transforming the neuromorphic simulation system from a proof-of-concept to a production-ready platform.*",
    "file": "ARCHITECTURE.md",
    "line": 648
  }
]